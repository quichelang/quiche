#![allow(unused_parens)]
#![allow(dropping_copy_types)]
#![allow(dropping_references)]

// Generated by elevate compiler.
// Do not edit generated output manually.

// ownership-note: experimental flag enabled: exp_type_system

#[derive(Debug, Clone)]
pub struct Point {
    pub x: i64,
    pub y: i64,
}

#[derive(Debug, Clone)]
pub struct Rect {
    pub top_left: Point,
    pub bottom_right: Point,
}

#[derive(Debug, Clone)]
pub struct Node {
    pub value: i64,
    pub name: String,
}

#[derive(Debug, Clone)]
pub struct TreeNode {
    pub value: i64,
    pub left: Option<Box<TreeNode>>,
    pub right: Option<Box<TreeNode>>,
}

#[derive(Debug, Clone)]
pub struct Container {
    pub items: Vec<i64>,
    pub name: String,
}

#[derive(Debug, Clone)]
pub struct DeepNested {
    pub container: Container,
    pub point: Point,
}

pub fn test_primitive_copy() -> () {
    let x: i64 = 42;
    let y: i64 = x;
    assert!(
        (x == 42),
        ::std::string::String::from("{}"),
        ::std::string::String::from("original should remain")
    );
    assert!(
        (y == 42),
        ::std::string::String::from("{}"),
        ::std::string::String::from("copy should match")
    );
}

pub fn test_bool_operations() -> () {
    let a: bool = true;
    let b: bool = false;
    assert!((a == true));
    assert!((b == false));
    assert!((a != b));
    assert!(((a && b) == false));
    assert!(((a || b) == true));
}

pub fn test_arithmetic() -> () {
    assert!(((1 + 2) == 3));
    assert!(((10 - 3) == 7));
    assert!(((4 * 5) == 20));
    assert!(((10 / 2) == 5));
    assert!(((17 % 5) == 2));
}

pub fn test_primitive_mutation() -> () {
    let mut x: i64 = 42;
    let y: i64 = x;
    x = (x + 1);
    assert!((x == 43));
    assert!((y == 42));
}

pub fn test_vector_mutation() -> () {
    let mut v: Vec<i64> = vec![1, 2, 3];
    let u: &Vec<i64> = &v;
    v.push(4);
    assert!((v == vec![1, 2, 3, 4]));
    assert!((u == vec![1, 2, 3, 4]));
}
