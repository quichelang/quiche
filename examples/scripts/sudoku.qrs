# Sudoku Solver - Backtracking Algorithm
# Solves a 9x9 Sudoku puzzle using constraint propagation and backtracking

def print_board(board: Vec[Vec[i32]]):
    """Pretty-print the sudoku board"""
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print("------+-------+------")
        row_str: String = "".to_string()
        for j in range(9):
            if j % 3 == 0 and j != 0:
                row_str.push_str(" | ")
            val: i32 = board[i][j]
            if val == 0:
                row_str.push_str(" .")
            else:
                row_str.push_str(" ")
                row_str.push_str(ref(val.to_string()))
        print(row_str)

def find_empty_row(board: ref[Vec[Vec[i32]]]) -> i32:
    """Find row of first empty cell. Returns -1 if none."""
    for i in range(9):
        for j in range(9):
            if board[i][j] == 0:
                return i as i32
    return -1

def find_empty_col(board: ref[Vec[Vec[i32]]], row_idx: usize) -> i32:
    """Find col of first empty cell in given row."""
    for j in range(9):
        if board[row_idx][j] == 0:
            return j as i32
    return -1

def is_valid(board: ref[Vec[Vec[i32]]], row: usize, col: usize, num: i32) -> bool:
    """Check if placing num at (row, col) is valid"""
    # Check row
    for j in range(9):
        if board[row][j] == num:
            return False
    
    # Check column
    for i in range(9):
        if board[i][col] == num:
            return False
    
    # Check 3x3 box
    box_row: usize = (row / 3) * 3
    box_col: usize = (col / 3) * 3
    for i in range(3):
        for j in range(3):
            if board[box_row + i][box_col + j] == num:
                return False
    
    return True

def solve(board: mutref[Vec[Vec[i32]]]) -> bool:
    """Solve the sudoku using backtracking"""
    row: i32 = find_empty_row(ref(deref(board)))
    
    if row == -1:
        # No empty cells - puzzle solved!
        return True
    
    row_idx: usize = row as usize
    col: i32 = find_empty_col(ref(deref(board)), row_idx)
    col_idx: usize = col as usize
    
    # Try each number 1-9
    for num in range(1, 10):
        n: i32 = num as i32
        if is_valid(ref(deref(board)), row_idx, col_idx, n):
            # Place the number
            deref(board)[row_idx][col_idx] = n
            
            # Recursively try to solve
            if solve(board):
                return True
            
            # Backtrack - undo the placement
            deref(board)[row_idx][col_idx] = 0
    
    # No valid number found - trigger backtrack
    return False

def create_board() -> Vec[Vec[i32]]:
    """Create the example puzzle"""
    board: Vec[Vec[i32]] = Vec.new()
    
    # Row 0: [5, 3, 0, 0, 7, 0, 0, 0, 0]
    r0: Vec[i32] = Vec.new()
    r0.push(5)
    r0.push(3)
    r0.push(0)
    r0.push(0)
    r0.push(7)
    r0.push(0)
    r0.push(0)
    r0.push(0)
    r0.push(0)
    board.push(r0)
    
    # Row 1
    r1: Vec[i32] = Vec.new()
    r1.push(6)
    r1.push(0)
    r1.push(0)
    r1.push(1)
    r1.push(9)
    r1.push(5)
    r1.push(0)
    r1.push(0)
    r1.push(0)
    board.push(r1)
    
    # Row 2
    r2: Vec[i32] = Vec.new()
    r2.push(0)
    r2.push(9)
    r2.push(8)
    r2.push(0)
    r2.push(0)
    r2.push(0)
    r2.push(0)
    r2.push(6)
    r2.push(0)
    board.push(r2)
    
    # Row 3
    r3: Vec[i32] = Vec.new()
    r3.push(8)
    r3.push(0)
    r3.push(0)
    r3.push(0)
    r3.push(6)
    r3.push(0)
    r3.push(0)
    r3.push(0)
    r3.push(3)
    board.push(r3)
    
    # Row 4
    r4: Vec[i32] = Vec.new()
    r4.push(4)
    r4.push(0)
    r4.push(0)
    r4.push(8)
    r4.push(0)
    r4.push(3)
    r4.push(0)
    r4.push(0)
    r4.push(1)
    board.push(r4)
    
    # Row 5
    r5: Vec[i32] = Vec.new()
    r5.push(7)
    r5.push(0)
    r5.push(0)
    r5.push(0)
    r5.push(2)
    r5.push(0)
    r5.push(0)
    r5.push(0)
    r5.push(6)
    board.push(r5)
    
    # Row 6
    r6: Vec[i32] = Vec.new()
    r6.push(0)
    r6.push(6)
    r6.push(0)
    r6.push(0)
    r6.push(0)
    r6.push(0)
    r6.push(2)
    r6.push(8)
    r6.push(0)
    board.push(r6)
    
    # Row 7
    r7: Vec[i32] = Vec.new()
    r7.push(0)
    r7.push(0)
    r7.push(0)
    r7.push(4)
    r7.push(1)
    r7.push(9)
    r7.push(0)
    r7.push(0)
    r7.push(5)
    board.push(r7)
    
    # Row 8
    r8: Vec[i32] = Vec.new()
    r8.push(0)
    r8.push(0)
    r8.push(0)
    r8.push(0)
    r8.push(8)
    r8.push(0)
    r8.push(0)
    r8.push(7)
    r8.push(9)
    board.push(r8)
    
    return board

def main():
    board: Vec[Vec[i32]] = create_board()
    
    print("Sudoku Puzzle:")
    print_board(board.clone())
    print("")
    
    if solve(mutref(board)):
        print("Solution found:")
        print_board(board)
    else:
        print("No solution exists!")
