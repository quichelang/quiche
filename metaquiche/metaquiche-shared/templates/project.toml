# Project scaffolding templates
# Used by `quiche new` and project initialization

[project]
description = "Project scaffolding templates for Quiche projects"

[project.cargo_toml]
content = '''
[package]
name = "{{name}}"
version = "0.1.0"
edition = "2024"

# Break out of any parent workspace
[workspace]

[dependencies]
quiche-runtime = { path = "../quiche-runtime" } # TODO: Make relative path smarter or use registry
{{extra_sections}}
'''

[project.cargo_toml_lib_section]
content = '''

[lib]
path = "src/lib.rs"
'''

[project.cargo_toml_bin_section]
content = '''

[[bin]]
name = "{{name}}"
path = "src/main.rs"
'''

[project.build_rs]
content = '''
use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=src");
    let out_dir = env::var("OUT_DIR").unwrap();
    
    // Check for lib.qrs, lib.q, main.qrs, or main.q
    let is_lib_qrs = Path::new("src/lib.qrs").exists();
    let is_lib_q = Path::new("src/lib.q").exists();
    let is_lib = is_lib_qrs || is_lib_q;
    
    let source_path = if is_lib_qrs {
        "src/lib.qrs"
    } else if is_lib_q {
        "src/lib.q"
    } else if Path::new("src/main.qrs").exists() {
        "src/main.qrs"
    } else {
        "src/main.q"
    };
    let dest_name = if is_lib { "lib.rs" } else { "main.rs" };
    let dest_path = Path::new(&out_dir).join(dest_name);

    if Path::new(source_path).exists() {
        // Use QUICHE_COMPILER_BIN if set, otherwise try relative path
        let compiler = env::var("QUICHE_COMPILER_BIN")
            .unwrap_or_else(|_| "{{compiler_bin}}".to_string());
        
        let output = Command::new(&compiler)
            .arg("--emit-rust")
            .arg(source_path)
            .output()
            .expect(&format!("Failed to run quiche compiler: {}", compiler));
        
        if output.status.success() {
            fs::write(&dest_path, &output.stdout).expect("Write output failed");
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            panic!("Compilation failed:\n{}", stderr);
        }
    } else {
        fs::write(&dest_path, "").unwrap();
    }
}
'''

[project.lib_rs]
content = '''
// This file is autogenerated by Quiche.
// Do not modify this file directly. Modify .qrs files in src/ instead.
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

use quiche_runtime::*;
use quiche_runtime::check;

// Re-export everything from the transpiled module
include!(concat!(env!("OUT_DIR"), "/lib.rs"));
'''

[project.main_rs]
content = '''
// This file is autogenerated by Quiche.
// Do not modify this file directly. Modify .qrs files in src/ instead.
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

use quiche_runtime::*;
use quiche_runtime::check;

include!(concat!(env!("OUT_DIR"), "/main.rs"));
'''

[project.lib_qrs]
content = '''

def hello():
    print("Hello from Lib!")
'''

[project.main_qrs]
content = '''

def main():
    print("Hello, Quiche!")
'''

[project.quiche_toml]
content = '''
[package]
name = "{{name}}"
version = "0.1.0"
'''
