# Runtime module templates
# Embedded in generated Rust code to provide core macros

[runtime]
description = "Quiche runtime module templates"

[runtime.quiche_module]
content = '''
mod quiche {
    #![allow(unused_macros, unused_imports)]

    macro_rules! qref {
        ($e:expr) => { &($e) };
    }
    pub(crate) use qref;

    macro_rules! mutref {
        ($e:expr) => { &mut ($e) };
    }
    pub(crate) use mutref;

    macro_rules! deref {
        ($e:expr) => { *($e) };
    }
    pub(crate) use deref;

    macro_rules! strcat {
        ($arg:expr) => { ($arg).to_string() };
        ($first:expr, $($rest:expr),+ $(,)?) => {{
            let mut __s = ($first).to_string();
            $( __s.push_str(&($rest).to_string()); )+
            __s
        }};
    }
    pub(crate) use strcat;
}
'''

[runtime.quiche_module_run]
content = '''
mod quiche {
    #![allow(unused_macros, unused_imports)]

    // High Priority: Consumes Self (Result/Option)
    pub trait QuicheResult {
        type Output;
        fn quiche_handle(self) -> Self::Output;
    }

    impl<T, E: std::fmt::Debug> QuicheResult for Result<T, E> {
        type Output = T;
        fn quiche_handle(self) -> T {
            self.expect("Quiche Error")
        }
    }

    // Low Priority: Takes &Self (Clone fallback)
    pub trait QuicheGeneric {
        fn quiche_handle(&self) -> Self;
    }

    impl<T: Clone> QuicheGeneric for T {
        fn quiche_handle(&self) -> Self {
            self.clone()
        }
    }

    macro_rules! check {
        ($val:expr) => {
            {
                use crate::quiche::{QuicheResult, QuicheGeneric};
                ($val).quiche_handle()
            }
        };
    }
    pub(crate) use check;
    pub(crate) use check as call;

    macro_rules! qref {
        ($e:expr) => { &($e) };
    }
    pub(crate) use qref;

    macro_rules! mutref {
        ($e:expr) => { &mut ($e) };
    }
    pub(crate) use mutref;

    macro_rules! deref {
        ($e:expr) => { *($e) };
    }
    pub(crate) use deref;

    macro_rules! strcat {
        ($arg:expr) => { ($arg).to_string() };
        ($first:expr, $($rest:expr),+ $(,)?) => {{
            let mut __s = ($first).to_string();
            $( __s.push_str(&($rest).to_string()); )+
            __s
        }};
    }
    pub(crate) use strcat;

    pub fn run_test_cmd(exe: String, test_path: String) -> bool {
        let mut cmd = std::process::Command::new(exe);
        cmd.arg(test_path);
        cmd.env("QUICHE_QUIET", "1");
        cmd.env("QUICHE_SUPPRESS_OUTPUT", "1");
        cmd.stdout(std::process::Stdio::null());
        cmd.stderr(std::process::Stdio::null());
        match cmd.status() {
            Ok(status) => status.success(),
            Err(_) => false,
        }
    }

    pub fn list_test_files() -> Vec<String> {
        let mut tests = Vec::new();
        if let Ok(entries) = std::fs::read_dir("tests") {
            for entry in entries.flatten() {
                let name = entry.file_name().to_string_lossy().to_string();
                if !name.ends_with(".qrs") || name == "runner.qrs" {
                    continue;
                }
                tests.push(name);
            }
        }
        tests.sort();
        tests
    }
}
'''

[runtime.lib_rs_wrapper]
content = '''
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

{{quiche_module}}

// Re-export everything from the transpiled module
include!(concat!(env!("OUT_DIR"), "/lib.rs"));
'''

[runtime.main_rs_wrapper]
content = '''
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

{{quiche_module}}

include!(concat!(env!("OUT_DIR"), "/main.rs"));
'''

[runtime.run_wrapper]
content = '''
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

{{quiche_module}}

{{user_code}}
'''
