
from rust.quiche_parser.ast import Stmt, QuicheModule

from compiler.codegen import Codegen
from rust.parsley_qrs import Parsley
from std.collections import HashMap
from std.any import Any
from std.io import Error as IoError

# Unit type alias for Rust ()
@extern(path="()", no_generic=True)
class Unit:
    pass

@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def push_str(self, s: StrRef): pass
    def clone(self) -> RustString: pass

@extern(path="quiche_parser::parser::ParseError", no_generic=True)
class ParseError:
    pass

@extern(path="quiche_parser::parse")
def parse_module(source: StrRef) -> Result[QuicheModule, ParseError]:
    pass

@extern(path="crate::quiche::env_args_helper")
def env_args() -> Vec[String]: pass

@extern(path="std::fs::read_to_string")
def read_to_string(path: String) -> Result[String, IoError]: pass 

@extern(path="std::process::exit")
def exit(code: i32): pass

# --- Error Handling Helpers ---
# unwrap_or_exit_io: Unwrap Result[String, IoError] or print error and exit
def unwrap_or_exit_io(result: Result[String, IoError], msg: String) -> String:
    match result:
        case Ok(v): return v
        case Err(e):
            print(msg + ": " + e.to_string())
            exit(1)
    return ""  # unreachable

# unwrap_or_exit_parse: Unwrap Result[QuicheModule, ParseError] or print error and exit
def unwrap_or_exit_parse(result: Result[QuicheModule, ParseError], msg: String) -> QuicheModule:
    match result:
        case Ok(v): return v
        case Err(e):
            print(msg + ": " + e.to_string())
            exit(1)
    # Create dummy module for unreachable path
    match result:
        case Ok(v): return v
        case _: exit(1)
    exit(1)

# unwrap_or_exit_unit: Unwrap Result[(), IoError] or print error and exit
def unwrap_or_exit_unit(result: Result[Unit, IoError], msg: String):
    match result:
        case Ok(_): pass
        case Err(e):
            print(msg + ": " + e.to_string())
            exit(1)

# unwrap_or_default_io: Unwrap Result[String, IoError] or return default value
def unwrap_or_default_io(result: Result[String, IoError], default: String) -> String:
    match result:
        case Ok(v): return v
        case Err(_): return default

@extern(path="crate::quiche::path_dirname")
def path_dirname(path: String) -> String: pass

@extern(path="crate::quiche::build_module_index")
def build_module_index(root: String) -> HashMap[String, String]: pass

@extern(path="crate::quiche::module_path_for_file")
def module_path_for_file(root: String, filename: String) -> String: pass

@extern(path="crate::quiche::module_parent")
def module_parent(path: String, levels: u32) -> String: pass

@extern(path="crate::quiche::dedup_shadowed_let_mut")
def dedup_shadowed_let_mut(code: String) -> String: pass

@extern(path="crate::quiche::module_join")
def module_join(base: String, sub: String) -> String: pass

# Template accessor functions for codegen parity
@extern(path="crate::quiche::codegen_template")
def codegen_template(key: String) -> String: pass

@extern(path="crate::quiche::path_exists")
def path_exists(path: String) -> bool: pass

@extern(path="crate::quiche::create_dir_all")
def create_dir_all(path: String) -> Result[Unit, IoError]: pass

@extern(path="crate::quiche::write_string")
def write_string(path: String, contents: String) -> Result[Unit, IoError]: pass

@extern(path="crate::quiche::copy_file")
def copy_file(src: String, dst: String) -> Result[Unit, IoError]: pass

@extern(path="crate::quiche::set_env_var")
def set_env_var(key: String, value: String): pass

@extern(path="crate::quiche::current_exe_path")
def current_exe_path() -> String: pass

@extern(path="crate::quiche::run_cargo_command")
def run_cargo_command(cmd: String, args: Vec[String]) -> bool: pass

@extern(path="crate::quiche::run_rust_code")
def run_rust_code(user_code: String, script_args: Vec[String], quiet: bool, suppress_output: bool, raw_output: bool, warn: bool, strict: bool, release: bool) -> i32: pass

@extern(path="crate::quiche::compiler_path_for_new")
def compiler_path_for_new() -> String: pass

@extern(path="crate::quiche::print_stdout")
def print_stdout(s: String): pass

@extern(path="crate::quiche::read_stdin")
def read_stdin() -> String: pass

# --- i18n Bridge Functions ---
@extern(path="crate::quiche::tr")
def tr(key: String) -> String: pass

@extern(path="crate::quiche::tr1")
def tr1(key: String, name: String, value: String) -> String: pass

@extern(path="crate::version_info::get_stage")
def version_get_stage() -> String: pass

@extern(path="crate::version_info::get_commit")
def version_get_commit() -> String: pass

@extern(path="crate::version_info::get_date")
def version_get_date() -> String: pass

@extern(path="crate::version_info::get_build_kind")
def version_get_build_kind() -> String: pass

@extern(path="quiche_runtime::ast_transformer::transform_module")
def transform_module(module: QuicheModule, verbose: bool) -> QuicheModule: pass

def get_flag_bool(flags: HashMap[String, bool], key: String) -> bool:
    match flags.get(ref(key)):
        case Some(v): return v.clone()
        case None: pass
    return False


class WarnFlags:
    warn: bool
    strict: bool
    warn_all: bool
    warn_quiche: bool

    def new(warn: bool, strict: bool, warn_all: bool, warn_quiche: bool) -> WarnFlags:
        return create_WarnFlags(warn, strict, warn_all, warn_quiche)


@extern(path="crate::quiche::ImportMaps", no_generic=True)
class ImportMaps:
    paths: HashMap[String, String]
    kinds: HashMap[String, String]

    def new(paths: HashMap[String, String], kinds: HashMap[String, String]) -> ImportMaps:
        return create_ImportMaps(paths, kinds)

@extern(path="crate::quiche::create_ImportMaps")
def create_ImportMaps(paths: HashMap[String, String], kinds: HashMap[String, String]) -> ImportMaps: pass


def module_to_rust_path(module_path: String) -> String:
    if module_path == "": return "crate"
    is_external = False
    res = module_path.clone()
    if res.starts_with(ref("rust.")):
        res = res.replace(ref("rust."), ref(""))
        is_external = True
    elif res.starts_with(ref("std.")):
        is_external = True
    if not is_external:
        res = "crate.".to_string() + ref(res)
    return res.replace(ref("."), ref("::"))


def resolve_module_path(current_module_path: String, module_name: String, level: u32) -> String:
    base = ""
    if level > 0:
        base = module_parent(current_module_path.clone(), level)
    if module_name == "":
        return base
    if base != "":
        return module_join(base, module_name)
    return module_name


def collect_module_exports(module_index: HashMap[String, String], module_path: String) -> HashMap[String, String]:
    exports = HashMap[String, String].new()
    match module_index.get(ref(module_path)):
        case Some(path):
            source = unwrap_or_exit_io(read_to_string(path.clone()), "Failed to read module")
            module = unwrap_or_exit_parse(parse_module(source.as_str()), "Failed to parse module")
            for stmt in module.body:
                match stmt:
                    case Stmt.ClassDef(c):
                        exports.insert(c.name.to_string(), "class")
                    case Stmt.FunctionDef(f):
                        exports.insert(f.name.to_string(), "func")
                    case _: pass
        case None: pass
    return exports


def build_import_maps(stmts: Vec[Stmt], module_index: HashMap[String, String], current_module_path: String) -> ImportMaps:
    import_paths = HashMap[String, String].new()
    import_kinds = HashMap[String, String].new()

    for stmt in stmts:
        match stmt:
            case Stmt.Import(i):
                for alias in i.names:
                    module_name = alias.name.to_string()
                    alias_name = module_name.clone()
                    match alias.asname.clone():
                        case Some(a):
                            alias_name = a.to_string()
                        case None: pass
                    module_path = resolve_module_path(current_module_path.clone(), module_name, 0)
                    rust_path = module_to_rust_path(module_path)
                    import_paths.insert(alias_name.clone(), rust_path)
                    import_kinds.insert(alias_name.clone(), "module")
            case Stmt.ImportFrom(i):
                base_module = ""
                match i.module:
                    case Some(m):
                        if m.to_string() == "lib.test": continue
                        base_module = resolve_module_path(current_module_path.clone(), m.to_string(), i.level)
                    case None:
                        base_module = resolve_module_path(current_module_path.clone(), "", i.level)

                is_external = base_module.starts_with(ref("rust.")) or base_module.starts_with(ref("std."))
                exports = HashMap[String, String].new()
                if not is_external:
                    match module_index.get(ref(base_module.clone())):
                        case Some(_):
                            exports = collect_module_exports(module_index.clone(), base_module.clone())
                        case None: pass

                for alias in i.names:
                    name = alias.name.to_string()
                    alias_name = name.clone()
                    match alias.asname.clone():
                        case Some(a): alias_name = a.to_string()
                        case None: pass

                    kind = "value"
                    item_module = module_join(base_module.clone(), name.clone())
                    rust_path = ""
                    match module_index.get(ref(item_module.clone())):
                        case Some(_):
                            kind = "module"
                            rust_path = module_to_rust_path(item_module)
                        case None:
                            rust_path = module_to_rust_path(base_module.clone())
                            rust_path = rust_path + ref("::")
                            rust_path = rust_path + ref(name)
                            if is_external:
                                kind = "module"
                            else:
                                match exports.get(ref(name.clone())):
                                    case Some(k):
                                        if k.as_str() == "class": kind = "type"
                                        elif k.as_str() == "func": kind = "func"
                                        else: kind = "value"
                                    case None: kind = "value"

                    import_paths.insert(alias_name.clone(), rust_path)
                    import_kinds.insert(alias_name.clone(), kind)
            case _:
                pass

    return ImportMaps.new(import_paths, import_kinds)

def normalize_module_path(module_path: String) -> String:
    if module_path == "main" or module_path == "lib":
        return ""
    return module_path


# --- Main ---

def compile_source_to_string(source: String, filename: String, warn_quiche: bool, strict: bool, verbose: bool) -> String:
    # Parse source with explicit error handling
    module = unwrap_or_exit_parse(parse_module(source.as_str()), "Failed to parse source")
    
    if filename.ends_with(ref(".q")):
        module = transform_module(module, verbose)

    stmts = module.body

    root_dir = path_dirname(filename.clone())
    module_index = build_module_index(root_dir.clone())
    current_module_path = normalize_module_path(module_path_for_file(root_dir.clone(), filename.clone()))
    import_maps = build_import_maps(stmts.clone(), module_index, current_module_path.clone())
    
    # Codegen
    codegen = Codegen.new_with_imports_and_module(import_maps.paths, import_maps.kinds, current_module_path)
    for stmt in stmts:
        codegen.generate_stmt(stmt)
    
    cleaned = dedup_shadowed_let_mut(codegen.output)
    return cleaned

    return ""

def compile_source(source: String, filename: String, warn_quiche: bool, strict: bool):
    code = compile_source_to_string(source, filename, warn_quiche, strict, False)
    print_stdout(code)

def print_usage():
    print(tr("cli.usage.header"))
    print(tr("cli.usage.new"))
    print(tr("cli.usage.build"))
    print(tr("cli.usage.run"))
    print(tr("cli.usage.test"))
    print("  qtest [pattern]    Run qtest-based unit tests")
    print(tr("cli.usage.script"))
    print("")
    print("Flags:")
    print("  --warn               Show compiler warnings")
    print("  --strict             Treat warnings as errors")
    print("  --warn-all           Show all warnings (Quiche + Rust)")
    print("  --warn-quiche        Show only Quiche warnings")
    print("  -m, --emit-rust      Emit generated Rust code instead of running")
    print("  -c <code>            Run inline code (use - for stdin)")
    print("  -v, --verbose        Show verbose output")
    print("  -r, --release        Build in release mode (optimized)")
    print("  -o, --out <file>     Write output to file")

def build_flag_parser(include_lib: bool) -> Parsley:
    parser = Parsley.new()
    parser.add_flag("warn-all", ["--warn"], False)
    parser.add_flag("warn-quiche", [], False)
    parser.add_flag("strict", [], False)
    parser.add_flag("emit-rust", ["-m"], False)
    parser.add_flag("verbose", ["-v"], False)
    parser.add_flag("release", ["-r", "--release"], False)
    parser.add_option("output", ["-o", "--out"], "", False)
    parser.add_option("code", ["-c"], "", False)
    if include_lib:
        parser.add_flag("lib", [], False)
    return parser

def parse_warn_flags(flags: HashMap[String, bool]) -> WarnFlags:
    warn_all = False
    warn_quiche = False
    strict = False
    k1 = "warn-all"
    warn_all = get_flag_bool(flags.clone(), k1)
    k2 = "warn-quiche"
    warn_quiche = get_flag_bool(flags.clone(), k2)
    k3 = "strict"
    strict = get_flag_bool(flags.clone(), k3)
    warn = warn_all
    if warn_all:
        warn = True
    return WarnFlags.new(warn, strict, warn_all, warn_quiche)

def template_quiche_toml(name: String) -> String:
    return "[package]\nname = \"" + name.as_str() + ref("\"\nversion = \"0.1.0\"\n")

def template_cargo_toml(name: String, is_lib: bool, compiler_path: String) -> String:
    extra = ""
    if is_lib:
        extra = codegen_template("project.cargo_toml_lib_section")
    else:
        extra = codegen_template("project.cargo_toml_bin_section").replace(ref("{{name}}"), ref(name.as_str()))
    
    return codegen_template("project.cargo_toml").replace(ref("{{name}}"), ref(name.as_str())).replace(ref("{{compiler_path}}"), ref(compiler_path.as_str())).replace(ref("{{extra_sections}}"), ref(extra.as_str()))

def template_build_rs() -> String:
    return codegen_template("project.build_rs")

def template_lib_qrs() -> String:
    return codegen_template("project.lib_qrs")

def template_main_qrs() -> String:
    return codegen_template("project.main_qrs")

def template_lib_rs() -> String:
    return codegen_template("project.lib_rs")

def template_main_rs() -> String:
    return codegen_template("project.main_rs")

def create_new_project(name: String, is_lib: bool):
    if path_exists(name.clone()):
        print(tr1("cli.error.dir_exists", "name", name))
        return

    unwrap_or_exit_unit(create_dir_all(name.clone() + ref("/src")), "Failed to create directory")
    unwrap_or_exit_unit(write_string(name.clone() + ref("/Quiche.toml"), template_quiche_toml(name.clone())), "Failed to write Quiche.toml")
    compiler_path = compiler_path_for_new()
    unwrap_or_exit_unit(write_string(name.clone() + ref("/Cargo.toml"), template_cargo_toml(name.clone(), is_lib, compiler_path)), "Failed to write Cargo.toml")
    unwrap_or_exit_unit(write_string(name.clone() + ref("/build.rs"), template_build_rs()), "Failed to write build.rs")

    if is_lib:
        unwrap_or_exit_unit(write_string(name.clone() + ref("/src/lib.qrs"), template_lib_qrs()), "Failed to write lib.qrs")
        unwrap_or_exit_unit(write_string(name.clone() + ref("/src/lib.rs"), template_lib_rs()), "Failed to write lib.rs")
    else:
        unwrap_or_exit_unit(write_string(name.clone() + ref("/src/main.qrs"), template_main_qrs()), "Failed to write main.qrs")
        unwrap_or_exit_unit(write_string(name.clone() + ref("/src/main.rs"), template_main_rs()), "Failed to write main.rs")

    print(tr1("cli.success.project_created", "name", name))

def run_transpiled_file(filename: String, script_args: Vec[String], quiet: bool, suppress_output: bool, raw_output: bool, warn: bool, strict: bool, warn_quiche: bool, output: String, verbose: bool, release: bool):
    source = unwrap_or_exit_io(read_to_string(filename.clone()), "Failed to read source file")
    rust_code = compile_source_to_string(source, filename.clone(), warn_quiche, strict, verbose)
    # The original instruction had a syntax error and undefined 'success'.
    # Assuming the intent was to ensure exit_code is an i32, and run_rust_code returns an i32.
    # If `run_rust_code` returns a boolean or similar, this would need adjustment.
    # For now, we keep the original call and add a type hint.
    exit_code: i32 = run_rust_code(rust_code, script_args, quiet, suppress_output, raw_output, warn, strict, release)
    
    if output != "":
        # Save binary
        unwrap_or_exit_unit(copy_file("target/tmp_bin".to_string(), output.clone()), "Failed to save binary")
        if verbose:
            print("Binary saved to: " + output.clone())

    if exit_code != 0:
        exit(exit_code)

def main():
    cli_args: Vec[String] = env_args()
    args: Vec[String] = []
    i = 0
    for arg in cli_args:
        if i > 0:
            args.push(arg)
        i = i + 1

    if args.len() == 0:
        print(tr("cli.error.no_command"))
        print_usage()
        exit(1)

    # Check for -c inline code option early
    parser = build_flag_parser(False)
    result = parser.parse(args.clone())
    inline_code = ""
    k_code = "code"
    match result.options.get(ref(k_code)):
        case Some(v): inline_code = v.clone()
        case None: pass
    
    if inline_code != "":
        # Handle inline code: -c "code" or -c - (stdin)
        source = ""
        if inline_code == "-":
            source = read_stdin()
        else:
            source = inline_code.clone()
        
        flags = parse_warn_flags(result.flags.clone())
        emit_rust = False
        emit_rust = get_flag_bool(result.flags.clone(), "emit-rust")
        verbose = False
        verbose = get_flag_bool(result.flags.clone(), "verbose")
        
        if emit_rust:
            code = compile_source_to_string(source, "<inline>".to_string(), flags.warn_quiche, flags.strict, verbose)
            print_stdout(code)
        else:
            release = False
            release = get_flag_bool(result.flags.clone(), "release")
            code = compile_source_to_string(source, "<inline>".to_string(), flags.warn_quiche, flags.strict, verbose)
            run_rust_code(code, result.positionals, True, False, True, flags.warn, flags.strict, release)
        return

    commands = ["new", "build", "run", "test", "qtest", "version"]
    cmd = args[0]
    has_command = False
    for c in commands:
        if c == cmd:
            has_command = True

    if has_command:
        subargs: Vec[String] = []
        j = 1
        while j < args.len():
            subargs.push(args[j])
            j = j + 1

        if cmd == "new":
            parser = build_flag_parser(True)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            if result.positionals.len() < 1:
                print(tr("cli.error.missing_project_name"))
                print(tr("cli.usage.new"))
                exit(1)
            name = result.positionals[0]
            is_lib = False
            k_lib = "lib"
            k_lib = "lib"
            is_lib = get_flag_bool(result.flags.clone(), k_lib)
            create_new_project(name, is_lib)
            return

        if cmd == "build":
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            
            cargo_args = result.positionals.clone()
            release_cmd = False
            release_cmd = get_flag_bool(result.flags.clone(), "release")
            if release_cmd:
                cargo_args.push("--release")

            success: bool = run_cargo_command("build", cargo_args)
            if not success:
                exit(1)
            return

        if cmd == "run":
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            if path_exists("Cargo.toml"):
                cargo_args = result.positionals.clone()
                release_cmd = False
                release_cmd = get_flag_bool(result.flags.clone(), "release")
                if release_cmd:
                    cargo_args.push("--release")

                success_run: bool = run_cargo_command("run", cargo_args)
                if not success_run:
                    exit(1)
            else:
                print(tr("cli.error.no_cargo_toml"))
                print(tr("cli.hint.single_script"))
                exit(1)
            return

        if cmd == "test":
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            flags = parse_warn_flags(result.flags.clone())
            if flags.warn_all:
                flags.warn_quiche = True
            if path_exists("tests/runner.qrs"):
                exe = current_exe_path()
                if exe != "":
                    set_env_var("QUICHE_TEST_BIN", exe)
                if flags.warn_all:
                    set_env_var("QUICHE_WARN_ALL", "1")
                if flags.warn_quiche:
                    set_env_var("QUICHE_WARN_QUICHE", "1")
                
                verbose = False
                verbose = get_flag_bool(result.flags.clone(), "verbose")

                release = False
                release = get_flag_bool(result.flags.clone(), "release")

                run_transpiled_file("tests/runner.qrs", result.positionals, True, False, True, flags.warn, flags.strict, flags.warn_quiche, "", verbose, release)
            elif path_exists("Cargo.toml"):
                cargo_args = result.positionals.clone()
                release_cmd = False
                release_cmd = get_flag_bool(result.flags.clone(), "release")
                if release_cmd:
                    cargo_args.push("--release")

                success_test: bool = run_cargo_command("test", cargo_args)
                if not success_test:
                    exit(1)
            else:
                print(tr("cli.error.no_tests_found"))
                exit(1)
            return
        
        if cmd == "qtest":
            # Run qtest-based unit tests
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            flags = parse_warn_flags(result.flags.clone())
            if flags.warn_all:
                flags.warn_quiche = True
            
            verbose = False
            verbose = get_flag_bool(result.flags.clone(), "verbose")
            release = False
            release = get_flag_bool(result.flags.clone(), "release")
            
            if path_exists("tests/qtest_runner.qrs"):
                run_transpiled_file("tests/qtest_runner.qrs", result.positionals, True, False, True, flags.warn, flags.strict, flags.warn_quiche, "", verbose, release)
            else:
                print("No tests/qtest_runner.qrs found")
                print("Create one with test functions that return TestResult")
                exit(1)
            return

        if cmd == "version":
            stage = version_get_stage()
            commit = version_get_commit()
            date = version_get_date()
            kind = version_get_build_kind()
            
            print(concat2("quiche-self ", ref(stage)))
            print(concat2("  stage:   ", ref(stage)))
            print(concat2("  commit:  ", ref(commit)))
            print(concat2("  built:   ", ref(date)))
            print(concat2("  profile: ", ref(kind)))
            return

    if cmd.ends_with(ref(".qrs")) or cmd.ends_with(ref(".q")):
        if not path_exists(cmd.clone()):
            print(tr1("cli.error.file_not_found", "file", cmd))
            exit(1)
        parser = build_flag_parser(False)
        rest: Vec[String] = []
        k = 1
        while k < args.len():
            rest.push(args[k])
            k = k + 1
        result = parser.parse(rest)
        if result.errors.len() > 0:
            for e in result.errors:
                print(e)
            print_usage()
            exit(1)
        flags = parse_warn_flags(result.flags.clone())
        
        emit_rust = False
        k_er = "emit-rust"
        emit_rust = get_flag_bool(result.flags.clone(), k_er)

        verbose = False
        k_v = "verbose"
        verbose = get_flag_bool(result.flags.clone(), k_v)

        output = ""
        k_o = "output"
        match result.options.get(ref(k_o)):
            case Some(v): output = v.clone()
            case None: pass

        release = False
        release = get_flag_bool(result.flags.clone(), "release")

        if emit_rust:
             source = unwrap_or_exit_io(read_to_string(cmd.clone()), "Failed to read source file")
             code = compile_source_to_string(source, cmd.clone(), flags.warn_quiche, flags.strict, verbose)
             print_stdout(code)
             return

        if flags.warn_all:
            flags.warn_quiche = True
        run_transpiled_file(cmd.clone(), result.positionals, False, False, True, flags.warn, flags.strict, flags.warn_quiche, output, verbose, release)
        return

    print(tr1("cli.error.unrecognized_command", "cmd", cmd))
    print("")
    print_usage()
    exit(1)
