import rust.quiche_parser.ast as q_ast
from rust.quiche_runtime import deref, qref


# extern_defs is provided by the wrapper module


from compiler.type_utils import infer_type as util_infer_type
from compiler.type_utils import type_to_string as util_type_to_string
from compiler.type_utils import is_tuple as util_is_tuple
from compiler.type_utils import get_root as util_get_root
from compiler.type_utils import is_type_or_module as util_is_type_or_module
from compiler.type_utils import contains_name as util_contains_name
# Using extern_defs from wrapper
# ============================================================================
# CODEGEN CORE - Main class, fields, constructors, and core utilities
# ============================================================================

class Codegen:
    output: RustString
    tuple_vars: HashMap[String, bool]
    defined_vars: Vec[HashMap[String, bool]]
    import_paths: HashMap[String, String]
    def infer_expr_type(self, expr: q_ast.Expr) -> String:
        return util_infer_type(expr)

    def type_to_string(self, expr: q_ast.Expr) -> String:
        return util_type_to_string(expr)

    def is_tuple_expr(self, expr: q_ast.Expr) -> bool:
        return util_is_tuple(expr)

    def is_var_defined_in_scopes(self, name: String) -> bool:
        i = self.defined_vars.len()
        while i > 0:
            i = i - 1
            scope = ref(self.defined_vars[i.clone()])
            match scope.get(ref(name.clone())):
                case Some(_): return True
                case None: pass
        return False

    def get_root_name(self, expr: q_ast.Expr) -> Option[String]:
        match expr:
            case q_ast.Expr.Name(n): return Some(n.to_string())
            case q_ast.Expr.Attribute(value=v, attr=a):
                return self.get_root_name(deref(v.clone()))
            case q_ast.Expr.Subscript(value=v, slice=s):
                return self.get_root_name(deref(v.clone()))
            case q_ast.Expr.Call(func=f, args=a, keywords=k):
                return self.get_root_name(deref(f.clone()))
            case _: return None

    def is_type_or_mod(self, name: String) -> bool:
        if name == "self": return False
        # Check for known module names
        if name == "extern_defs": return True
        # Check import registry
        match self.import_kinds.get(ref(name)):
             case Some(k):
                  if k.as_str() == "module" or k.as_str() == "type": return True
             case None: pass
        # Check for uppercase first letter (type naming convention)
        if name.len() > 0:
            first_char = name.chars().next()
            match first_char:
                case Some(c):
                    if c.is_uppercase(): return True
                case None: pass
        return False

    def is_var_defined(self, name: String) -> bool:
        return False

    def enter_var_scope(self):
        self.defined_vars.push(HashMap[String, bool].new())

    def exit_var_scope(self):
        sz = self.defined_vars.len()
        if sz > 1:
            self.defined_vars.pop()

    def mark_var_defined(self, name: String):
        sz = self.defined_vars.len()
        idx = sz - 1
        current_scope: HashMap[String, bool] = self.defined_vars[idx.clone()]
        current_scope.insert(name, True)
        self.defined_vars[idx.clone()] = current_scope
    
    def define_var(self, name: String):
        self.mark_var_defined(name)

    def expr_contains_name(self, expr: q_ast.Expr, name: String) -> bool:
        return util_contains_name(expr, name)

    def generate_pattern(self, pat: q_ast.Pattern):
        match pat:
            case q_ast.Pattern.MatchValue(v): self.emit_pattern_path(deref(v))
            case q_ast.Pattern.MatchAs(pattern=pattern, name=name):
                match name:
                    case Some(n): self.emit(n)
                    case None: self.emit("_")
            case q_ast.Pattern.MatchClass(c):
                self.emit_pattern_path(deref(c.cls))
                if c.patterns.len() > 0:
                    self.emit("(")
                    first_p = True
                    for p in c.patterns.clone():
                        if not first_p: self.emit(", ")
                        self.generate_pattern(p)
                        first_p = False
                    self.emit(")")
                elif c.kwd_patterns.len() > 0:
                    self.emit(" { ")
                    idx_kw_pat = 0
                    for pat in c.kwd_patterns.clone():
                        if idx_kw_pat > 0: self.emit(", ")
                        # We need the attr name here but kwd_patterns is Vec<Pattern>
                        # kwd_attrs is parallel Vec<String>
                        attr_name = c.kwd_attrs[idx_kw_pat]
                        self.emit(attr_name)
                        self.emit(": ")
                        self.generate_pattern(pat)
                        idx_kw_pat = idx_kw_pat + 1
                    self.emit(", .. }")
                else: self.emit(" { .. }")
            case q_ast.Pattern.MatchSingleton(c):
                match c:
                    case q_ast.Constant.NoneVal: self.emit("None")
                    case q_ast.Constant.Bool(b):
                        if b: self.emit("true")
                        else: self.emit("false")
                    case q_ast.Constant.Str(s):
                        self.emit("\"")
                        self.emit(s.to_string())
                        self.emit("\"")
                    case q_ast.Constant.Int(i): self.emit(i.to_string())
                    case _: self.emit("_")
            case q_ast.Pattern.MatchSequence(pats):
                self.emit("(")
                first_seq = True
                for p_seq in pats.clone():
                    if not first_seq: self.emit(", ")
                    self.generate_pattern(p_seq)
                    first_seq = False
                self.emit(")")
            case _: self.emit("_")

    import_kinds: HashMap[String, String]
    clone_names: bool
    current_module_path: String
    class_fields: HashMap[String, HashMap[String, String]]
    current_class: String

    def is_skip_check_method(self, method_name: String) -> bool:
        # Methods that are known to be infallible and don't need check! wrapping
        # This list must match the host compiler exactly
        if method_name.as_str() == "as_str": return True
        if method_name.as_str() == "to_string": return True
        if method_name.as_str() == "clone": return True
        if method_name.as_str() == "into_syntax": return True
        if method_name.as_str() == "into_iter": return True
        if method_name.as_str() == "as_ref": return True
        if method_name.as_str() == "ref": return True
        if method_name.as_str() == "mutref": return True
        if method_name.as_str() == "enter_var_scope": return True
        if method_name.as_str() == "exit_var_scope": return True
        if method_name.as_str() == "get_root_name": return True
        if method_name.as_str() == "is_type_or_mod": return True
        if method_name.as_str() == "is_var_defined": return True
        if method_name.as_str() == "mark_var_defined": return True
        if method_name.as_str() == "define_var": return True
        if method_name.as_str() == "expr_contains_name": return True
        if method_name.as_str() == "generate_pattern": return True
        if method_name.as_str() == "emit": return True
        if method_name.as_str() == "push": return True
        return False

    def __init__(self):
        self.output = RustString.new()
        self.tuple_vars = HashMap[String, bool].new()
        self.defined_vars = [HashMap[String, bool].new()]
        self.import_paths = HashMap[String, String].new()
        self.import_kinds = HashMap[String, String].new()
        self.clone_names = True
        self.current_module_path = ""
        self.class_fields = HashMap[String, HashMap[String, String]].new()
        self.current_class = ""

    def new() -> Codegen:
        return extern_defs.create_codegen(output=RustString.new(), tuple_vars=HashMap[String, bool].new(), defined_vars=[HashMap[String, bool].new()], import_paths=HashMap[String, String].new(), import_kinds=HashMap[String, String].new(), clone_names=True, current_module_path="", class_fields=HashMap.new(), current_class="")

    def new_with_imports(import_paths: HashMap[String, String], import_kinds: HashMap[String, String]) -> Codegen:
        return extern_defs.create_codegen(output=RustString.new(), tuple_vars=HashMap[String, bool].new(), defined_vars=[HashMap[String, bool].new()], import_paths=import_paths, import_kinds=import_kinds, clone_names=True, current_module_path="", class_fields=HashMap.new(), current_class="")

    def new_with_imports_and_module(import_paths: HashMap[String, String], import_kinds: HashMap[String, String], current_module_path: String) -> Codegen:
        return extern_defs.create_codegen(
            output=RustString.new(),
            tuple_vars=HashMap[String, bool].new(),
            defined_vars=[HashMap[String, bool].new()],
            import_paths=import_paths,
            import_kinds=import_kinds,
            clone_names=True,
            current_module_path=current_module_path,
            class_fields=HashMap.new(),
            current_class=""
        )

    def generate_expr_no_clone(self, expr: q_ast.Expr):
        prev = self.clone_names
        self.clone_names = False
        self.generate_expr(expr)
        self.clone_names = prev

    def emit_lvalue_target(self, expr: q_ast.Expr):
        # Emit raw variable/expression for use as mutation target (no &mut/& prefix, no .clone())
        match expr:
            case q_ast.Expr.Name(n):
                self.emit(n.to_string())
            case q_ast.Expr.Subscript(value=value, slice=slice):
                # For nested subscripts like obj["y"][1], emit recursively
                self.emit_lvalue_target(deref(value.clone()))
                self.emit("[")
                # If the slice is a string literal, it's a HashMap key - add & prefix
                lvalue_slice_is_string = False
                match deref(slice.clone()):
                    case q_ast.Expr.Constant(c):
                        match c:
                            case q_ast.Constant.Str(_): lvalue_slice_is_string = True
                            case _: pass
                    case _: pass
                if lvalue_slice_is_string:
                    self.emit("&")
                self.generate_expr(deref(slice.clone()))
                self.emit("]")
            case q_ast.Expr.Attribute(value=value, attr=attr):
                self.emit_lvalue_target(deref(value.clone()))
                self.emit(".")
                self.emit(attr.clone())
            case _:
                # Fallback to generate_expr_no_clone for other cases
                self.generate_expr_no_clone(expr)

    def emit_pattern_path(self, expr: q_ast.Expr):
        # Emit type/enum path using :: for all segments (for match case patterns)
        match expr:
            case q_ast.Expr.Name(n):
                self.emit(n.to_string())
            case q_ast.Expr.Attribute(value=value, attr=attr):
                self.emit_pattern_path(deref(value.clone()))
                self.emit("::")
                self.emit(attr.clone())
            case _:
                self.generate_expr(expr)

    def register_class_field(self, class_name: String, field_name: String, field_type: String):
        match self.class_fields.get(ref(class_name.clone())):
            case Some(cf_untyped):
                class_fields_map: HashMap[String, String] = cf_untyped.clone()
                class_fields_map.insert(field_name.clone(), field_type.clone())
            case None:
                class_fields_map: HashMap[String, String] = HashMap[String, String].new()
                class_fields_map.insert(field_name.clone(), field_type.clone())
                self.class_fields.insert(class_name.clone(), class_fields_map)

    def set_current_class(self, class_name: String):
        self.current_class = class_name

    def clear_current_class(self):
        self.current_class = ""

    def get_self_field_type(self, field_name: String) -> String:
        if self.current_class == "": return ""
        match self.class_fields.get(ref(self.current_class.clone())):
            case Some(cf_untyped):
                class_fields_map: HashMap[String, String] = cf_untyped.clone()
                match class_fields_map.get(ref(field_name.clone())):
                    case Some(t): return t.clone()
                    case None: return ""
            case None: return ""




    def emit(self, s: String):
        self.output.push_str(ref(s))



    # ========================================================================
    # TYPE UTILITIES - Corresponds to types.rs in host compiler
    # ========================================================================

    def emit_type_params(self, type_params: Vec[String]):
        """Emit generic type parameters like <T> or <T: Display>
        
        type_params is Vec<String> where each string is a type param like
        "T" or "T: Display" (already lowered by the parser).
        """
        if type_params.len() > 0:
            self.emit("<")
            first = True
            for tp in type_params:
                if not first:
                    self.emit(", ")
                first = False
                self.emit(tp)
            self.emit(">")

    # ========================================================================
    # STATEMENT EMISSION - Corresponds to stmt.rs in host compiler
    # ========================================================================

    def generate_stmt(self, stmt: q_ast.Stmt):
        match stmt:
            case q_ast.Stmt.FunctionDef(f):
                self.emit_function_def(f)
            case q_ast.Stmt.Expr(e):
                self.emit_stmt_expr(deref(e))
            case q_ast.Stmt.Return(r):
                self.emit_return(r)
            case q_ast.Stmt.Assign(a):
                self.emit_assign(a)
            case q_ast.Stmt.AnnAssign(a):
                self.emit_ann_assign(a)
            case q_ast.Stmt.For(f):
                self.emit_for(f)
            case q_ast.Stmt.If(i):
                self.emit_if(i)
            case q_ast.Stmt.While(w):
                self.emit_while(w)
            case q_ast.Stmt.ClassDef(c):
                self.emit_class_def(c)
            case q_ast.Stmt.Match(m):
                self.emit_match(m)
            case q_ast.Stmt.Import(i):
                self.emit_import(i)
            case q_ast.Stmt.ImportFrom(i):
                self.emit_import_from(i)
            case q_ast.Stmt.Assert(a):
                self.emit_assert(a)
            case q_ast.Stmt.Pass:
                pass  # Do nothing - empty statement in Rust
            case q_ast.Stmt.Break:
                self.emit("break;\n")
            case q_ast.Stmt.Continue:
                self.emit("continue;\n")
            case _:
                self.emit("// Unimplemented stmt\n")

    def emit_assert(self, a: q_ast.AssertStmt):
        self.emit("assert!(")
        self.generate_expr(deref(a.test))
        match a.msg:
            case Some(m):
                self.emit(", \"{:?}\", ")
                m_expr = deref(m)
                self.generate_expr(m_expr)
            case None: pass
        self.emit(");\n")

    def emit_function_def(self, f: q_ast.FunctionDef):
        # Check for @extern
        is_extern = False
        extern_path = ""
        for dec in f.decorator_list.clone():
            match dec:
                case q_ast.Expr.Name(n):
                    if n.to_string() == "extern":
                        is_extern = True
                case q_ast.Expr.Call(func=func, args=args, keywords=keywords):
                    match ref(deref(func)):
                        case q_ast.Expr.Name(func_name):
                            if func_name.to_string() == "extern":
                                is_extern = True
                                for kw in keywords.clone():
                                    match ref(kw.arg):
                                        case Some(arg_name):
                                            if arg_name.as_str() == "path":
                                                match ref(deref(kw.value)):
                                                    case q_ast.Expr.Constant(c):
                                                        match c:
                                                            case q_ast.Constant.Str(s):
                                                                extern_path = s.to_string()
                                                            case _: pass
                                                    case _: pass
                                            elif arg_name.as_str() == "no_generic":
                                                 pass
                                        case _: pass
                        case _: pass
                case _: pass
        
        # if f.decorator_list.len() > 0:
        #    self.emit_function_def_decorator(f)
        #    return

        if is_extern:
             pass
        func_name = f.name.to_string()
        if is_extern:
            if extern_path != "":
                self.emit("pub use ")
                self.emit(extern_path)
                self.emit(" as ")
                self.emit(func_name)
                self.emit(";\n")
            else:
                self.emit("// Extern function ")
                self.emit(func_name)
                self.emit("\n")
            return

        self.emit("pub fn ")
        self.emit(func_name)
        
        # Emit generic type parameters if present
        self.emit_type_params(f.type_params)
        
        self.emit("(")
        self.enter_var_scope()
        # Register keys and emit args
        first_arg: bool = True
        for param in f.args.clone():
            if not first_arg:
                self.emit(", ")
            first_arg = False

            if param.arg.to_string() == "self":
                self.emit("&mut self")
            else:
                self.emit(param.arg.to_string())
                self.emit(": ")
                if param.annotation.is_some():
                    ann = param.annotation.clone().unwrap()
                    ann_expr = deref(ann.clone())
                    type_name = self.type_to_string(ann_expr)
                    self.emit(type_name.clone())
                    self.mark_var_defined(param.arg.to_string())
                else:
                    self.emit("Any")
                    pass
        self.emit(")")
        if f.returns.is_some():
            ret = f.returns.clone().unwrap()
            ret_type = self.type_to_string(deref(ret.clone()))
            self.emit(" -> ")
            self.emit(ret_type)
        self.emit(" {\n")

        for s in f.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}\n")

    def emit_stmt_expr(self, e: q_ast.QuicheExpr):
        is_doc = False
        match ref(e):
            case q_ast.Expr.Constant(c):
                match c:
                    case q_ast.Constant.Str(s):
                        is_doc = True
                        self.emit("#![doc = \"")
                        self.emit(escape_rust_string(s.to_string()))
                        self.emit("\"]\n")
                    case _: pass
            case _: pass

        if not is_doc:
            self.generate_expr(e)
            self.emit(";\n")

    def emit_return(self, r: Option[Box[q_ast.Expr]]):
        self.emit("return ")
        match r:
            case Some(v):
                v_expr = deref(v)
                self.generate_expr(v_expr)
            case None: pass
        self.emit(";\n")

    def emit_assign(self, a: q_ast.Assign):
        # Simple single target assignment
        is_subscript = False
        subscript_is_map = False
        match ref(a.targets[0]):
            case q_ast.Expr.Name(n):
                name_assign = n.to_string()
                is_existing = self.is_var_defined_in_scopes(name_assign.clone())
                if not is_existing:
                    if self.expr_contains_name(Clone.clone(ref(deref(a.value))), name_assign.clone()):
                        is_existing = True
                if not is_existing:
                    self.emit("let mut ")
                self.emit(name_assign.clone())
                self.emit(" = ")
                assign_val_type = self.infer_expr_type(Clone.clone(ref(deref(a.value))))
                if not is_existing:
                    self.define_var(name_assign.clone())
                    self.mark_var_defined(name_assign.clone())
                match ref(deref(a.value)):
                    case q_ast.Expr.Tuple(_):
                        self.tuple_vars.insert(name_assign.clone(), True)
                    case _: pass
            case q_ast.Expr.Attribute(value=value, attr=attr):
                # Reconstruct Attribute expr for emission
                # We can't easily clone the whole struct variant from fields, so we just construct what emit_attribute_target needs
                # Actually helper takes expr 
                # Let's fix emit_attribute_target later, for now inline simple emission
                self.generate_expr(deref(value))
                self.emit(".")
                self.emit(attr.clone())
                self.emit(" = ")
            case q_ast.Expr.Subscript(value=value, slice=slice):
                self.emit_lvalue_target(deref(value.clone()))
                self.emit("[")
                self.generate_expr(deref(slice.clone()))
                self.emit("] = ")
            case _: pass
        self.generate_expr(deref(a.value))
        self.emit(";\n")

    def emit_ann_assign(self, a: q_ast.AnnAssign):
        match ref(deref(a.target)):
            case q_ast.Expr.Name(n):
                ann_type_name = self.type_to_string(Clone.clone(ref(deref(a.annotation.clone()))))
                is_tuple_ann = ann_type_name.starts_with(ref("(")) or ann_type_name.starts_with(ref("Tuple"))
                self.emit("let mut ")
                self.emit(n.to_string())
                self.emit(": ")
                self.emit(ann_type_name.clone())
                self.emit(" = ")
                self.mark_var_defined(n.to_string())
                if is_tuple_ann:
                    self.tuple_vars.insert(n.to_string(), True)
            case _: pass
        match a.value:
            case Some(v):
                v_expr = deref(v)
                self.generate_expr(v_expr)
            case None:
                self.emit("Default::default()")
        self.emit(";\n")

    def emit_for(self, f: q_ast.ForStmt):
        prev_clone = self.clone_names
        self.clone_names = True
        self.emit("for __q in (")
        match ref(deref(f.iter)):
            case q_ast.Expr.Name(n):
                self.emit(n.to_string())
            case _:
                self.generate_expr(deref(f.iter))
        self.emit(") {\n")
        self.emit("let ")
        match ref(deref(f.target)):
            case q_ast.Expr.Name(n):
                self.emit(n.to_string())
            case _:
                self.emit("_")
        self.emit(" = __q;\n")
        self.enter_var_scope()
        self.clone_names = prev_clone
        for s in f.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}\n")

    def emit_if(self, i: q_ast.IfStmt):
        self.emit("if ")
        self.generate_expr(deref(i.test))
        self.emit(" {\n")
        self.enter_var_scope()
        for s in i.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}\n")
        
        if i.orelse.len() > 0:
            self.emit("else {\n")
            self.enter_var_scope()
            for s in i.orelse:
                self.generate_stmt(s)
            self.exit_var_scope()
            self.emit("}\n")

    def emit_while(self, w: q_ast.WhileStmt):
        self.emit("while ")
        self.generate_expr(deref(w.test))
        self.emit(" {\n")
        self.enter_var_scope()
        for s in w.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}\n")

    def emit_class_def(self, c: q_ast.ClassDef):
        is_enum = False
        is_extern = False
        extern_path = ""
        no_generic = False

        # Support class Name(Struct) or class Name(Enum)
        for base in c.bases.clone():
             match ref(base):
                 case q_ast.Expr.Name(n):
                     if n.to_string() == "Enum": is_enum = True
                     if n.to_string() == "Extern": is_extern = True
                 case _: pass

        # Support decorators (legacy)
        for dec in c.decorator_list.clone():
            match dec:
                case q_ast.Expr.Name(n):
                    if n.to_string() == "enum":
                        is_enum = True
                    if n.to_string() == "extern":
                        is_extern = True
                case q_ast.Expr.Call(func=func, args=args, keywords=keywords):
                    match ref(deref(func)):
                        case q_ast.Expr.Name(func_name):
                            if func_name.to_string() == "extern":
                                is_extern = True
                                for kw in keywords.clone():
                                    match ref(kw.arg):
                                        case Some(arg_name):
                                            if arg_name.as_str() == "path":
                                                match ref(deref(kw.value)):
                                                    case q_ast.Expr.Constant(c):
                                                        match c:
                                                            case q_ast.Constant.Str(s):
                                                                extern_path = s.to_string()
                                                            case _: pass
                                                    case _: pass
                                            elif arg_name.as_str() == "no_generic":
                                                match ref(deref(kw.value)):
                                                    case q_ast.Expr.Constant(c):
                                                        match c:
                                                            case q_ast.Constant.Bool(b):
                                                                no_generic = Clone.clone(b)
                                                            case _: pass
                                                    case q_ast.Expr.Name(n):
                                                        if n.to_string() == "true":
                                                            no_generic = True
                                                    case _: pass
                                        case _: pass
                        case _: pass
                case _: pass

        class_name = c.name.to_string()

        if is_extern:
            if extern_path != "":
                self.emit("pub type ")
                self.emit(c.name.to_string())
                if no_generic:
                    self.emit(" = ")
                    self.emit(extern_path)
                    self.emit(";\n")
                else:
                    self.emit("<T> = ")
                    self.emit(extern_path)
                    self.emit("<T>;\n")
            else:
                self.emit("// Extern class ")
                self.emit(c.name.to_string())
                self.emit("\n")
            return

        if is_enum:
             self.emit("#[derive(Clone, Debug)]\n")
             self.emit("pub enum ")
        else:
             self.emit("#[derive(Clone, Debug, Default)]\n")
             self.emit("pub struct ")
        self.emit(c.name.to_string())
        self.emit("  {\n")

        if is_enum:
            for s in c.body.clone():
                match s:
                    case q_ast.Stmt.AnnAssign(a):
                        match ref(deref(a.target)):
                            case q_ast.Expr.Name(n):
                                self.emit(n.to_string())
                                self.emit("(")
                                match deref(a.annotation):
                                    case q_ast.Expr.List(elts):
                                        idx_enum: usize = 0
                                        for t in elts.clone():
                                            if idx_enum > 0: self.emit(", ")
                                            t_str_enum = self.type_to_string(t)
                                            self.emit(t_str_enum)
                                            idx_enum = idx_enum + 1
                                    case _: pass
                                self.emit("),\n")
                            case _: pass
                    case _: pass
        else:
            for s in c.body.clone():
                match s:
                    case q_ast.Stmt.AnnAssign(a):
                        match ref(deref(a.target)):
                            case q_ast.Expr.Name(n):
                                self.emit("pub ")
                                self.emit(n.to_string())
                                self.emit(": ")
                                ann_str_f = self.type_to_string(Clone.clone(ref(deref(a.annotation.clone()))))
                                self.register_class_field(class_name.clone(), n.to_string(), ann_str_f.clone())
                                self.emit(ann_str_f)
                                self.emit(",\n")
                            case _: pass
                    case _: pass
        self.emit("}\n\n")



        if not is_enum:
            self.emit("impl ")
            self.emit(c.name.to_string())
            self.emit(" {\n")
            self.set_current_class(class_name.clone())
            for s in c.body:
                match s:
                    case q_ast.Stmt.FunctionDef(_):
                        self.generate_stmt(s)
                    case _: pass
            self.clear_current_class()
            self.emit("}\n\n")

    def emit_match(self, m: q_ast.MatchStmt):
        self.emit("match ")
        self.generate_expr(deref(m.subject))
        self.emit(" {\n")
        for case_ in m.cases:
            self.generate_pattern(case_.pattern.clone())
            match case_.guard:
                case Some(g):
                    self.emit(" if ")
                    g_expr = deref(g.clone())
                    self.generate_expr(g_expr)
                case None: pass
            self.emit(" => {\n")
            self.enter_var_scope()
            for s in case_.body:
                self.generate_stmt(s)
            self.exit_var_scope()
            self.emit("}\n")
        self.emit("}\n")

    def emit_import(self, i: q_ast.Import):
        dot_imp = "."
        sep_imp = "::"
        for alias in i.names:
            is_root_module = self.current_module_path == "" or self.current_module_path == "main" or self.current_module_path == "lib"
            alias_name_raw = alias.name.to_string()
            rust_p = "rust."
            std_p = "std."
            alias_name = alias.name.to_string()
            match alias.asname.clone():
                case Some(a): alias_name = a.to_string()
                case None: pass

            rust_path_opt: Option[String] = None
            match self.import_paths.get(ref(alias_name.clone())):
                case Some(p): rust_path_opt = Some(p.clone())
                case None: pass

            match rust_path_opt:
                case Some(rust_path):
                    if is_root_module and rust_path.starts_with(ref("crate::")):

                        continue
                    self.emit("use ")
                    self.emit(rust_path)
                    match alias.asname.clone():
                        case Some(_):
                            self.emit(" as ")
                            self.emit(alias_name.clone())
                        case None: pass
                    self.emit(";\n")
                case None:
                    if not alias_name_raw.starts_with(rust_p.as_str()) and not alias_name_raw.starts_with(std_p.as_str()):
                        if is_root_module and alias.asname.is_none() and not alias_name_raw.contains(ref(".")):

                            continue
                        self.emit("use crate::")
                    else:
                        self.emit("use ")
                    dot_v = "."
                    sep_v = "::"
                    self.emit(alias_name_raw.replace(dot_v.as_str(), sep_v.as_str()))
                    self.emit(";\n")
            


    def emit_import_from(self, i: q_ast.ImportFrom):
        mod_sep = "."
        mod_col = "::"
        for alias in i.names:
            match i.module.clone():
                case Some(m):
                    if m.to_string() == "lib.test": return
                case None: pass
            alias_name = alias.name.to_string()
            match alias.asname.clone():
                case Some(a): alias_name = a.to_string()
                case None: pass

            rust_path_opt: Option[String] = None
            match self.import_paths.get(ref(alias_name.clone())):
                case Some(p): rust_path_opt = Some(p.clone())
                case None: pass
            
            match rust_path_opt:
                case Some(rust_path):
                    self.emit("use ")
                    self.emit(rust_path)
                    match alias.asname.as_ref():
                        case Some(_):
                            self.emit(" as ")
                            self.emit(alias_name.clone())
                        case None: pass
                    self.emit(";\n")
                case None:
                    self.emit("use ")
                    match i.module.clone():
                        case Some(m):
                            m_str: String = m.to_string()
                            if m_str == "lib.test": return
                            r_p = "rust."
                            s_p = "std."
                            if not m_str.starts_with(r_p.as_str()) and not m_str.starts_with(s_p.as_str()):
                                if i.level == 0: self.emit("crate::")
                        case None: pass
                    l_lvl = i.level
                    k_lvl: u32 = 0
                    while k_lvl < l_lvl:
                        self.emit("super::")
                        k_lvl = k_lvl + 1
                    match i.module.clone():
                        case Some(m):
                            mod_name: String = m.to_string()
                            if mod_name == "rust":
                                mod_name = ""
                            elif mod_name.starts_with(ref("rust.")):
                                mod_name = mod_name.replace(ref("rust."), ref(""))
                            if mod_name != "":
                                self.emit(mod_name.replace(mod_sep.as_str(), mod_col.as_str()))
                                self.emit("::")
                        case None: pass
                    self.emit(alias.name.to_string().replace(mod_sep.as_str(), mod_col.as_str()))
                    match alias.asname.as_ref():
                        case Some(a):
                            self.emit(" as ")
                            self.emit(a.to_string())
                        case None: pass
                    self.emit(";\n")


    # ========================================================================
    # EXPRESSION EMISSION - Corresponds to expr.rs in host compiler
    # ========================================================================

    def generate_expr(self, expr: q_ast.Expr):
        match expr:
            case q_ast.Expr.Constant(c):
                match c:
                    case q_ast.Constant.Str(s):
                         self.emit("String::from(\"")
                         self.emit(escape_rust_string(s.to_string()))
                         self.emit("\")")
                    case q_ast.Constant.Int(i):
                         self.emit(i.to_string())
                    case q_ast.Constant.Float(f):
                         s_f = f.to_string()
                         dot_char = "."
                         dot_zero = ".0"
                         if not s_f.contains(dot_char.as_str()):
                             s_f.push_str(dot_zero.as_str())
                         self.emit(s_f)
                    case q_ast.Constant.Bool(b):
                         if b: self.emit("true")
                         else: self.emit("false")
                    case q_ast.Constant.NoneVal: self.emit("None")
                    case _: self.emit("/* const */")
            case q_ast.Expr.Name(n):
                name_str = n.to_string()
                if self.is_type_or_mod(name_str.clone()):
                    self.emit(name_str)
                else:
                    self.emit(name_str)
            case q_ast.Expr.Call(func=func, args=args, keywords=keywords):
                self.emit_call(func, args, keywords)
            case q_ast.Expr.List(l): self.emit_list(l)
            case q_ast.Expr.BinOp(left=left, op=op, right=right): self.emit_bin_op(left, op, right)
            case q_ast.Expr.BoolOp(op=op, values=values): self.emit_bool_op(op, values)
            case q_ast.Expr.UnaryOp(op=op, operand=operand): self.emit_unary_op(op, operand)
            case q_ast.Expr.IfExp(test=test, body=body, orelse=orelse): self.emit_expr_if(test, body, orelse)
            case q_ast.Expr.Compare(left=left, ops=ops, comparators=comparators): self.emit_compare(left, ops, comparators)
            case q_ast.Expr.Tuple(t): self.emit_expr_tuple(t)
            case q_ast.Expr.Attribute(value=value, attr=attr): self.emit_attribute(value, attr)
            case q_ast.Expr.Subscript(value=value, slice=slice): self.emit_subscript(value, slice)
            case q_ast.Expr.Lambda(args=args, body=body): self.emit_lambda(args, body)
            case _: self.emit("/* expr */")



    def emit_call(self, func: Box[q_ast.Expr], args: Vec[q_ast.Expr], keywords: Vec[q_ast.Keyword]):
        func_name = ""
        match ref(deref(func)):
            case q_ast.Expr.Lambda(args=l_args, body=l_body):
                self.generate_expr(deref(func))
                self.emit("(")
                idx_lc = 0
                for arg in args.clone():
                    if idx_lc > 0: self.emit(", ")
                    self.generate_expr(arg)
                    idx_lc = idx_lc + 1
                self.emit(")")
                return
            case _: pass
        match ref(deref(func)):
            case q_ast.Expr.Name(n):
                func_name = n.to_string()
            case _: pass

        if func_name == "as_ref" or func_name == "ref":
            if args.len() > 0:
                self.emit("qref!(")
                self.generate_expr_no_clone(Clone.clone(ref(args[0])))
                self.emit(")")
            return
        if func_name == "as_mut" or func_name == "mutref":
            if args.len() > 0:
                self.emit("mutref!(")
                self.generate_expr_no_clone(Clone.clone(ref(args[0])))
                self.emit(")")
            return
        if func_name == "deref":
            if args.len() > 0:
                self.emit("deref!(")
                self.generate_expr_no_clone(Clone.clone(ref(args[0])))
                self.emit(")")
            return
        if func_name == "exit":
            self.emit("std::process::exit(")
            idx_exit: usize = 0
            for arg in args.clone():
                if idx_exit > 0: self.emit(", ")
                self.generate_expr(arg)
                idx_exit = idx_exit + 1
            self.emit(")")
            return

        if func_name == "print":
            # Generate format string with correct number of {} placeholders
            fmt_parts: Vec[String] = []
            for _ in args.clone():
                fmt_parts.push("{}")
            fmt_str = fmt_parts.join(ref(" "))
            self.emit("println!(\"")
            self.emit(fmt_str)
            self.emit("\", ")
            first_p = True
            for arg in args.clone():
                if not first_p: self.emit(", ")
                first_p = False
                self.generate_expr(arg)
            self.emit(")")
            return
        elif func_name == "print_str":
            self.emit("println!(\"{}\", ")
            first_ps = True
            for arg in args.clone():
                if not first_ps: self.emit(", ")
                first_ps = False
                self.generate_expr(arg)
            self.emit(")")
        elif func_name == "assert_eq" or func_name == "assert_str_eq":
            self.emit("assert_eq!(")
            if args.len() >= 2:
                self.generate_expr(Clone.clone(ref(args[0])))
                self.emit(", ")
                self.generate_expr(Clone.clone(ref(args[1])))
                if args.len() > 2:
                    self.emit(", \"{:?}\", ")
                    self.generate_expr(Clone.clone(ref(args[2])))
            self.emit(")")
        elif func_name == "assert_true":
            self.emit("assert!(")
            if args.len() >= 1:
                self.generate_expr(Clone.clone(ref(args[0])))
                if args.len() > 1:
                    self.emit(", \"{:?}\", ")
                    self.generate_expr(Clone.clone(ref(args[1])))
            self.emit(")")
        elif func_name == "range":
            if args.len() == 1:
                self.emit("0..")
                self.generate_expr(Clone.clone(ref(args[0])))
            elif args.len() >= 2:
                self.generate_expr(Clone.clone(ref(args[0])))
                self.emit("..")
                self.generate_expr(Clone.clone(ref(args[1])))
        elif keywords.len() > 0:
            # Emit as function call with kwargs as positional args
            self.generate_expr(deref(func))
            self.emit("(")
            i_kw: usize = 0
            for arg_p in args.clone():
                if i_kw > 0: self.emit(", ")
                self.generate_expr(arg_p)
                i_kw = i_kw + 1
            for kw in keywords:
                if i_kw > 0: self.emit(", ")
                self.generate_expr(deref(kw.value.clone()))
                i_kw = i_kw + 1
            self.emit(")")
        else:
            match ref(deref(func)):
                case q_ast.Expr.Attribute(value=value, attr=attr):
                    if attr.as_str() == "new":
                        match ref(deref(value)):
                            case q_ast.Expr.Name(n):
                                base_name = n.to_string()
                                if base_name == "List" or base_name == "Vec":
                                    self.emit("Vec::new()")
                                    return
                                if base_name == "Dict" or base_name == "HashMap":
                                    self.emit("std::collections::HashMap::new()")
                                    return
                            case q_ast.Expr.Subscript(value=s_value, slice=s_slice):
                                base_name_s = self.type_to_string(Clone.clone(ref(deref(s_value))))
                                if base_name_s == "Vec":
                                    inner_s = self.type_to_string(Clone.clone(ref(deref(s_slice))))
                                    self.emit("Vec::<")
                                    self.emit(inner_s)
                                    self.emit(">::new()")
                                    return
                                if base_name_s == "std::collections::HashMap" or base_name_s == "HashMap":
                                    self.emit("std::collections::HashMap::new()")
                                    return
                            case _: pass

                    self.generate_expr(deref(func))
                    self.emit("(")
                    idx_arg_call = 0
                    for arg_c in args.clone():
                        if idx_arg_call > 0: self.emit(", ")
                        self.generate_expr(arg_c)
                        idx_arg_call = idx_arg_call + 1
                    self.emit(")")
                case _:
                    self.generate_expr(deref(func))
                    self.emit("(")
                    idx_arg_call = 0
                    for arg_c in args.clone():
                        if idx_arg_call > 0: self.emit(", ")
                        self.generate_expr(arg_c)
                        idx_arg_call = idx_arg_call + 1
                    self.emit(")")

    def emit_list(self, l: Vec[q_ast.Expr]):
        self.emit("vec![")
        idx_l: usize = 0
        for e in l.clone():
            if idx_l > 0: self.emit(", ")
            self.generate_expr(e)
            idx_l = idx_l + 1
        self.emit("]")

    def emit_bin_op(self, left: Box[q_ast.Expr], op: q_ast.Operator, right: Box[q_ast.Expr]):
        # Check if this is an Add operation that might be string concatenation
        match op:
            case q_ast.Operator.Add:
                # Check if any operand looks like a string (literal or involves strings)
                if self.is_string_expr(deref(left)) or self.is_string_expr(deref(right)):
                    # Flatten the chain and emit strcat!
                    left_parts = self.flatten_add_chain(deref(left))
                    right_parts = self.flatten_add_chain(deref(right))
                    parts: Vec[q_ast.Expr] = []
                    for p in left_parts:
                        parts.push(p)
                    for p in right_parts:
                        parts.push(p)
                    self.emit("crate::quiche::strcat!(")
                    idx: usize = 0
                    for part in parts.clone():
                        if idx > 0:
                            self.emit(", ")
                        self.generate_expr(part)
                        idx = idx + 1
                    self.emit(")")
                    return
            case _:
                pass
        # Non-string binary operations: emit normally
        self.generate_expr(deref(left))
        match op:
            case q_ast.Operator.Add: self.emit(" + ")
            case q_ast.Operator.Sub: self.emit(" - ")
            case q_ast.Operator.Mult: self.emit(" * ")
            case q_ast.Operator.Div: self.emit(" / ")
            case _: self.emit(" + ")
        self.generate_expr(deref(right))
    
    def is_string_expr(self, expr: q_ast.Expr) -> bool:
        """Check if expression appears to be a string"""
        match expr:
            case q_ast.Expr.Constant(c):
                match c:
                    case q_ast.Constant.Str(_): return True
                    case _: return False
            # Check if it's a BinOp Add containing strings
            case q_ast.Expr.BinOp(left=left, op=op, right=right):
                match op:
                    case q_ast.Operator.Add:
                        return self.is_string_expr(deref(left)) or self.is_string_expr(deref(right))
                    case _:
                        return False
            case _: return False
        return False
    
    def flatten_add_chain(self, expr: q_ast.Expr) -> Vec[q_ast.Expr]:
        """Flatten a chain of Add operations into a list of operands"""
        match expr.clone():
            case q_ast.Expr.BinOp(left=left, op=op, right=right):
                match op:
                    case q_ast.Operator.Add:
                        # Recursively flatten left and right
                        left_parts = self.flatten_add_chain(deref(left))
                        right_parts = self.flatten_add_chain(deref(right))
                        result: Vec[q_ast.Expr] = []
                        for p in left_parts:
                            result.push(p)
                        for p in right_parts:
                            result.push(p)
                        return result
                    case _:
                        pass
            case _:
                pass
        # Not an Add operation, return single element
        return [expr]

    def emit_bool_op(self, op: q_ast.BoolOperator, values: Vec[q_ast.Expr]):
        op_str_b = " && "
        match op:
            case q_ast.BoolOperator.Or: op_str_b = " || "
            case _: pass
        idx_b: usize = 0
        for v in values.clone():
            if idx_b > 0: self.emit(op_str_b.clone())
            self.emit("(")
            self.generate_expr(v)
            self.emit(")")
            idx_b = idx_b + 1

    def emit_unary_op(self, op: q_ast.UnaryOperator, operand: Box[q_ast.Expr]):
        match op:
            case q_ast.UnaryOperator.Not: self.emit("!")
            case q_ast.UnaryOperator.Invert: self.emit("!")
            case q_ast.UnaryOperator.UAdd: self.emit("+")
            case q_ast.UnaryOperator.USub: self.emit("-")
        self.generate_expr(deref(operand))

    def emit_expr_if(self, test: Box[q_ast.Expr], body: Box[q_ast.Expr], orelse: Box[q_ast.Expr]):
        self.emit("if ")
        self.generate_expr(deref(test))
        self.emit(" { ")
        self.generate_expr(deref(body))
        self.emit(" } else { ")
        self.generate_expr(deref(orelse))
        self.emit(" }")

    def emit_compare(self, left: Box[q_ast.Expr], ops: Vec[q_ast.CmpOperator], comparators: Vec[q_ast.Expr]):
        self.generate_expr(deref(left))
        idx_c: usize = 0
        while idx_c < ops.len():
            op = ops[idx_c]
            self.emit(" ")
            match op:
                case q_ast.CmpOperator.Eq: self.emit("==")
                case q_ast.CmpOperator.NotEq: self.emit("!=")
                case q_ast.CmpOperator.Lt: self.emit("<")
                case q_ast.CmpOperator.LtE: self.emit("<=")
                case q_ast.CmpOperator.Gt: self.emit(">")
                case q_ast.CmpOperator.GtE: self.emit(">=")
                case _: self.emit("?")
            self.emit(" ")
            self.generate_expr(Clone.clone(ref(comparators[idx_c])))
            idx_c = idx_c + 1

    def emit_expr_tuple(self, elts: Vec[q_ast.Expr]):
        self.emit("(")
        idx_t: usize = 0
        for e in elts:
            if idx_t > 0: self.emit(", ")
            self.generate_expr(e)
            idx_t = idx_t + 1
        self.emit(")")

    def emit_attribute(self, value: Box[q_ast.Expr], attr: String):
        target_attr = deref(value)
        is_static_attr = False
        match self.get_root_name(Clone.clone(ref(target_attr))):
            case Some(root_name):
                if self.is_type_or_mod(root_name.clone()):
                    is_static_attr = True
            case None: pass
        if attr.as_str() == "new": is_static_attr = True
        
        match ref(target_attr):
            case q_ast.Expr.Subscript(value=s_val, slice=s_slice):
                if is_static_attr:
                    full_expr = Clone.clone(ref(target_attr))
                    base_type = self.type_to_string(full_expr)
                    if base_type.contains(ref("<")):
                        base_type = base_type.replace(ref("<"), ref("::<"))
                    self.emit(base_type)
                else:
                    self.emit_lvalue_target(Clone.clone(ref(target_attr)))
            case _:
                if is_static_attr:
                    self.emit_pattern_path(Clone.clone(ref(target_attr)))
                else:
                    self.emit_lvalue_target(Clone.clone(ref(target_attr)))
        if is_static_attr: self.emit("::")
        else: self.emit(".")
        self.emit(attr)

    def emit_attribute_target(self, value: Box[q_ast.Expr], attr: String):
        target_attr = deref(value)
        is_static_attr = False
        match self.get_root_name(Clone.clone(ref(target_attr))):
            case Some(root_name):
                if self.is_type_or_mod(root_name.clone()):
                    is_static_attr = True
            case None: pass
        if attr.as_str() == "new": is_static_attr = True

        match ref(target_attr):
            case q_ast.Expr.Attribute(value=inner_val, attr=inner_attr):
                self.emit_attribute_target(inner_val.clone(), inner_attr.clone())
            case q_ast.Expr.Name(n):
                self.emit(n.to_string())
            case _:
                self.generate_expr_no_clone(Clone.clone(ref(target_attr)))
        if is_static_attr: self.emit("::")
        else: self.emit(".")
        self.emit(attr)

    def emit_subscript(self, value: Box[q_ast.Expr], slice: Box[q_ast.Expr]):
        is_neg_s = False
        target_type_s = self.infer_expr_type(Clone.clone(ref(deref(value))))
        is_tuple_target = self.is_tuple_expr(Clone.clone(ref(deref(value))))
        tuple_via_registry = False
        match ref(deref(value)):
            case q_ast.Expr.Name(n):
                match self.tuple_vars.get(ref(n.to_string())):
                    case Some(_):
                        tuple_via_registry = True
                    case None: pass
            case q_ast.Expr.Subscript(value=inner_value, slice=inner_slice):
                match ref(deref(inner_value)):
                    case q_ast.Expr.Name(n):
                        match self.tuple_vars.get(ref(n.to_string())):
                            case Some(_):
                                tuple_via_registry = True
                            case None: pass
                    case _: pass
            case _: pass

        if tuple_via_registry or is_tuple_target or target_type_s == "Tuple" or target_type_s.starts_with(ref("Tuple")) or target_type_s.starts_with(ref("(")):
            self.generate_expr(deref(value))
            self.emit(".")
            match deref(slice):
                case q_ast.Expr.Constant(c):
                    match c:
                        case q_ast.Constant.Int(i):
                            self.emit(i.to_string())
                        case _: self.emit("0")
                case _: self.emit("0")
        else:
            sl_s = deref(slice)
            match sl_s.clone():
                case q_ast.Expr.UnaryOp(op=op, operand=operand):
                     match op:
                        case q_ast.UnaryOperator.USub: is_neg_s = True
                        case _: pass
                case _: pass

            if is_neg_s:
                match sl_s:
                    case q_ast.Expr.UnaryOp(op=op, operand=operand):
                        self.generate_expr(Clone.clone(ref(deref(value))))
                        self.emit("[")
                        self.generate_expr(Clone.clone(ref(deref(value))))
                        self.emit(".len() - ")
                        self.generate_expr(deref(operand))
                        self.emit("].clone()")
                    case _: pass
            else:
                self.generate_expr(deref(value))
                self.emit("[")
                self.generate_expr(sl_s)
                self.emit("].clone()")

    def emit_lambda(self, args: Vec[String], body: Box[q_ast.Expr]):
        self.emit("(|")
        idx_lam = 0
        for arg in args.clone():
            if idx_lam > 0: self.emit(", ")
            self.emit(arg)
            idx_lam = idx_lam + 1
        self.emit("| ")
        self.generate_expr_no_clone(deref(body))
        self.emit(")")


