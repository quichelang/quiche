# Runtime module templates
# Embedded in generated Rust code to provide core macros

[runtime]
description = "Quiche runtime module templates"

[runtime.quiche_module]
content = '''
mod quiche {
    #![allow(unused_macros, unused_imports)]

    macro_rules! qref {
        ($e:expr) => { &($e) };
    }
    pub(crate) use qref;

    macro_rules! mutref {
        ($e:expr) => { &mut ($e) };
    }
    pub(crate) use mutref;

    macro_rules! deref {
        ($e:expr) => { *($e) };
    }
    pub(crate) use deref;

    macro_rules! strcat {
        ($arg:expr) => { ($arg).to_string() };
        ($first:expr, $($rest:expr),+ $(,)?) => {{
            let mut __s = ($first).to_string();
            $( __s.push_str(&($rest).to_string()); )+
            __s
        }};
    }
    pub(crate) use strcat;
}
'''

[runtime.quiche_module_run]
content = '''
mod quiche {
    #![allow(unused_macros, unused_imports)]

    macro_rules! qref {
        ($e:expr) => { &($e) };
    }
    pub(crate) use qref;

    macro_rules! mutref {
        ($e:expr) => { &mut ($e) };
    }
    pub(crate) use mutref;

    macro_rules! deref {
        ($e:expr) => { *($e) };
    }
    pub(crate) use deref;

    macro_rules! strcat {
        ($arg:expr) => { ($arg).to_string() };
        ($first:expr, $($rest:expr),+ $(,)?) => {{
            let mut __s = ($first).to_string();
            $( __s.push_str(&($rest).to_string()); )+
            __s
        }};
    }
    pub(crate) use strcat;

    // Re-export Managed type from the runtime crate
    pub use ::quiche_runtime::Managed;

    pub fn run_test_cmd(exe: String, test_path: String) -> bool {
        let mut cmd = std::process::Command::new(exe);
        cmd.arg(test_path);
        cmd.env("QUICHE_QUIET", "1");
        cmd.env("QUICHE_SUPPRESS_OUTPUT", "1");
        cmd.stdout(std::process::Stdio::null());
        cmd.stderr(std::process::Stdio::null());
        match cmd.status() {
            Ok(status) => status.success(),
            Err(_) => false,
        }
    }

    pub fn list_test_files() -> Vec<String> {
        let mut tests = Vec::new();
        if let Ok(entries) = std::fs::read_dir("tests") {
            for entry in entries.flatten() {
                let name = entry.file_name().to_string_lossy().to_string();
                if !name.ends_with(".qrs") || name == "runner.qrs" {
                    continue;
                }
                tests.push(name);
            }
        }
        tests.sort();
        tests
    }
}
'''

[runtime.lib_rs_wrapper]
content = '''
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

{{quiche_module}}

// Re-export everything from the transpiled module
include!(concat!(env!("OUT_DIR"), "/lib.rs"));
'''

[runtime.main_rs_wrapper]
content = '''
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

{{quiche_module}}

include!(concat!(env!("OUT_DIR"), "/main.rs"));
'''

[runtime.run_wrapper]
content = '''
#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]

{{quiche_module}}
use crate::quiche as quiche_runtime;
{{user_code}}
'''
