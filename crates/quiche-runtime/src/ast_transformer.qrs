from rust.quiche_parser.ast import QuicheModule, Stmt, Expr, FunctionDef, Arg, Operator, BoolOperator, UnaryOperator, IfStmt, WhileStmt, ForStmt, Keyword
from std.collections import HashMap

# Import memory analysis types and functions
from rust.crate import MemoryAnalyzer, MemConfig, AllocationStrategy
from rust.crate.memory_analysis import init_inline_types, collect_mem_decorators, get_strategy_for_type, get_func_config


@extern(path="crate::create_QuicheModule")
def create_QuicheModule(body: Vec[Stmt]) -> QuicheModule: pass

@extern(path="crate::box_expr")
def box_expr(e: Expr) -> Box[Expr]: pass

@extern(path="crate::ast_wrap_mutref_type")
def ast_wrap_mutref_type(e: Box[Expr]) -> Box[Expr]: pass

@extern(path="crate::ast_wrap_mutref_call")
def ast_wrap_mutref_call(e: Box[Expr]) -> Box[Expr]: pass

@extern(path="crate::ast_cast_usize")
def ast_cast_usize(e: Box[Expr]) -> Box[Expr]: pass

@extern(path="crate::ast_get_func_name")
def ast_get_func_name(f: FunctionDef) -> String: pass

@extern(path="crate::ast_update_func_body")
def ast_update_func_body(f: FunctionDef, body: Vec[Stmt]) -> FunctionDef: pass

@extern(path="crate::ast_update_arg_annotation")
def ast_update_arg_annotation(arg: Arg, ann: Option[Box[Expr]]) -> Arg: pass

@extern(path="crate::create_Transformer")
def create_Transformer() -> Transformer: pass

class Transformer:
    signatures: HashMap[String, Vec[bool]] # FuncName -> List of "needs_borrow" (true if complex)
    current_complex_args: Vec[String]
    memory_analyzer: MemoryAnalyzer  # Memory analysis state
    extern_returns: HashMap[String, String]  # FuncName -> Return Type String
    verbose: bool

    def new() -> Transformer:
        return create_Transformer()

    def transform_module(self, module: QuicheModule) -> QuicheModule:
        if self.verbose:
            print("Transformer: Starting memory analysis (Pass 0)...")
        
        # Pass 0: Memory Analysis - collect @mem decorators and analyze escape
        init_inline_types(mutref(self.memory_analyzer))
        self.extern_returns = HashMap[String, String].new()
        
        for stmt in module.body.clone():
            collect_mem_decorators(mutref(self.memory_analyzer), stmt.clone())
            # Also collect @extern functions
            self.collect_extern(stmt)
        
        if self.verbose:
            print("Transformer: Analyzing signatures (Pass 1)...")
        self.signatures = HashMap[String, Vec[bool]].new()
        
        # Pass 1: Collect Signatures & Transform Definitions
        pass1_body: Vec[Stmt] = []
        for stmt in module.body:
            pass1_body.push(self.visit_def(stmt))

        if self.verbose:
            print("Transformer: Transforming calls (Pass 2)...")
        # Pass 2: Transform Calls
        final_body: Vec[Stmt] = []
        for stmt in pass1_body:
            final_body.push(self.transform_stmt(stmt))
        
        return create_QuicheModule(final_body)

    def type_expr_to_string(self, expr: Expr) -> String:
        match expr:
            case Expr.Name(n):
                return n.clone()
            case Expr.Subscript(value=v, slice=s):
                # Handle generic types like Vec[i32], ref[T], etc.
                inner = self.type_expr_to_string(deref(s).clone())
                outer = self.type_expr_to_string(deref(v).clone())
                
                if outer == "ref":
                    return "&" + ref(inner)
                elif outer == "mutref":
                    return "&mut " + ref(inner)
                else:
                    return outer + "<" + ref(inner) + ">"
            case Expr.Tuple(elts):
                # Manual join since Vec.join might not be available
                res = "("
                first = True
                for e in elts:
                    if not first: res = res + ", "
                    first = False
                    res = res + ref(self.type_expr_to_string(e))
                return res + ")"
            case _:
                return "Any"

    def visit_def(self, stmt: Stmt) -> Stmt:
        match stmt:
            case Stmt.FunctionDef(f):
                # Analyze args
                new_args: Vec[Arg] = []
                signature: Vec[bool] = []
                func_name = ast_get_func_name(ref(f))

                for arg in f.args.clone():
                    new_arg = arg.clone()
                    is_complex = False
                    
                    # Check annotation to decide if we auto-borrow (make it mutref)
                    match arg.annotation:
                        case Some(ann):
                            # Inspect generic type inside Box
                            # We clone to inspect without consuming
                            inner = deref(ann).clone() 
                            if self.is_complex_type(inner.clone()):
                                is_complex = True
                                # Change annotation to mutref[Original]
                                # ann is Box[Expr]. We need to wrap it.
                                # But match moves ann? In Quiche match binds by value/move usually
                                # So ann is consumed here if we don't return it.
                                # actually match destructures.
                                # We want to wrap 'ann'.
                                # But 'ann' was bound.
                                # We need to use 'pass' or re-assign.
                            
                                # Create new wrapped annotation
                                # We need to clone inner again or use it?
                                # inner was cloned above.
                                wrapped = ast_wrap_mutref_type(box_expr(inner))
                                new_arg = ast_update_arg_annotation(new_arg, Some(wrapped))
                            
                            pass # end if
                        case None: pass
                    
                    signature.push(is_complex)
                    new_args.push(new_arg)
                    
                self.signatures.insert(func_name.clone(), signature.clone()) 
                if self.verbose:
                    print("Registered signature for: " + func_name + " -> " + signature.len().to_string())

                
                # Update function args locally (struct update not easy, we modify 'f.args'?)
                # f is owned. f.args is pub Vec.
                # In generated Rust: f.args = new_args works if f is mut.
                # But 'f' is immutable binding from match.
                # We need a helper to update args too?
                # Or just clone 'f' into 'mut f2'?
                # 'FunctionDef' derives Clone.
                # Let's use a helper 'ast_update_func_args' or assume we construct Stmt::FunctionDef(f) with new args?
                # Stmt::FunctionDef(f) constructor takes 'f'.
                # We can modify 'f' if we bind it mutably? No facile way in Quiche.
                # I'll add 'ast_update_func_args' helper to lib.rs quickly?
                # OR better: define a helper method on class that uses extern?
                # Actually, f.args = new_args works if f is mutable.
                # I will define 'make_mut_function_def(f) -> FunctionDef' helper (identity but ownership dance)?
                # Or simply:
                # updated_f = self.update_args(f, new_args)
                updated_f = self.update_args(f, new_args)
                return Stmt.FunctionDef(updated_f)
            case _:
                return stmt

    def update_args(self, f: FunctionDef, args: Vec[Arg]) -> FunctionDef:
        # We need to set f.args = args.
        # Since I can't easily mutate f here, I'll rely on an extern or helper.
        return ast_set_func_args(f, args)

    def is_complex_type(self, e: Expr) -> bool:
        match e:
            case Expr.Name(n):
                # Vec, String, or Capitalized class name
                return n == "Vec" or n == "String" or (n.len() > 0 and self.is_uppercase(n))
            case Expr.Subscript(value=val_box, slice=slice_box):
                return self.is_complex_type(deref(val_box).clone())
            case _:
                return False

    def is_uppercase(self, s: String) -> bool:
        # Check first char
        # Need helper? or s.chars().next()...
        # use an extern for 'is_first_upper'?
        return check_first_upper(s)

    def collect_extern(self, stmt: Stmt):
        """Collect @extern decorated functions and their return types"""
        match stmt:
            case Stmt.FunctionDef(f):
                if self.has_extern_decorator(f.decorator_list.clone()):
                    func_name = ast_get_func_name(ref(f))
                    
                    # Extract return type annotation
                    ret_type = "Any"
                    match f.returns:
                        case Some(ann):
                            ret_type = self.type_expr_to_string(deref(ann).clone())
                        case None:
                            pass
                            
                    self.extern_returns.insert(func_name.clone(), ret_type.clone())
                    
                    if self.verbose:
                        print("  Found @extern function: " + func_name + " -> " + ret_type)
            case _:
                pass
    
    def has_extern_decorator(self, decorators: Vec[Expr]) -> bool:
        """Check if decorator list contains @extern"""
        for dec in decorators:
            match dec:
                case Expr.Name(n):
                    if n == "extern":
                        return True
                case Expr.Call(func=fc, args=_, keywords=_):
                    inner = deref(fc).clone()
                    match inner:
                        case Expr.Name(n):
                            if n == "extern":
                                return True
                        case _:
                            pass
                case _:
                    pass
        return False

    def transform_stmt(self, stmt: Stmt) -> Stmt:
        match stmt:
            case Stmt.Expr(e):
                 # Transform top level expr
                 new_expr = self.transform_expr(deref(e).clone())
                 return Stmt.Expr(box_expr(new_expr))
            
            case Stmt.If(i):
                test = self.transform_expr(deref(i.test).clone())
                body: Vec[Stmt] = []
                for s in i.body: body.push(self.transform_stmt(s))
                orelse: Vec[Stmt] = []
                for s in i.orelse: orelse.push(self.transform_stmt(s))
                return make_if_stmt(box_expr(test), body, orelse)

            case Stmt.While(w):
                 test = self.transform_expr(deref(w.test).clone())
                 body: Vec[Stmt] = []
                 for s in w.body: body.push(self.transform_stmt(s))
                 orelse: Vec[Stmt] = []
                 for s in w.orelse: orelse.push(self.transform_stmt(s))
                 return make_while_stmt(box_expr(test), body, orelse)

            case Stmt.For(f):
                 target = f.target.clone() 
                 iter = self.transform_expr(deref(f.iter).clone())
                 body: Vec[Stmt] = []
                 for s in f.body: body.push(self.transform_stmt(s))
                 orelse: Vec[Stmt] = []
                 for s in f.orelse: orelse.push(self.transform_stmt(s))
                 return make_for_stmt(target, box_expr(iter), body, orelse)

            case Stmt.FunctionDef(f):
                 # Save previous scope args
                 old_complex = self.current_complex_args.clone()

                 # Populate new args
                 for arg in f.args.clone():
                     match arg.annotation:
                         case Some(ann):
                             # Check if annotation is mutref[...]
                             # Structure: Subscript(value=Name("mutref"), slice=...)
                             match deref(ann).clone():
                                 case Expr.Subscript(value=v, slice=s):
                                     match deref(v):
                                         case Expr.Name(n):
                                             if n == "mutref":
                                                 self.current_complex_args.push(arg.arg.clone())
                                         case _: pass
                                 case _: pass
                         case None: pass

                 # Recurse into body
                 new_body: Vec[Stmt] = []
                 for s in f.body.clone():
                     new_body.push(self.transform_stmt(s))
                 
                 # Restore scope
                 self.current_complex_args = old_complex

                 return Stmt.FunctionDef(ast_update_func_body(f, new_body))
            case Stmt.Return(r):
                 match r:
                     case Some(e):
                         inner = deref(e).clone()
                         return Stmt.Return(Some(box_expr(self.transform_expr(inner))))
                     case None:
                         return Stmt.Return(None)
            case Stmt.Assign(a):
                 # Transform targets and value
                 # targets: Vec[Expr]
                 # value: Box[Expr]
                 new_targets: Vec[Expr] = []
                 for t in a.targets:
                     new_targets.push(self.transform_expr(t))
                 
                 val_inner = deref(a.value).clone()
                 new_val = self.transform_expr(val_inner)
                 
                 # Construct Assign
                 # Need helper? 'ast_create_assign'
                 # Or Assign { targets: new_targets, value: box_expr(new_val) } (if supported)
                 # We established struct init not supported.
                 # I need 'ast_create_assign(targets, val)' helper.
                 return Stmt.Assign(ast_create_assign(new_targets, box_expr(new_val)))
                 
            case Stmt.If(i):
                test = self.transform_expr(deref(i.test).clone())
                body: Vec[Stmt] = []
                for s in i.body: body.push(self.transform_stmt(s))
                orelse: Vec[Stmt] = []
                for s in i.orelse: orelse.push(self.transform_stmt(s))
                return Stmt.If(ast_create_if(box_expr(test), body, orelse))

            case Stmt.For(f):
                 # target, iter, body, orelse
                 target = self.transform_expr(deref(f.target).clone())
                 iter = self.transform_expr(deref(f.iter).clone())
                 body: Vec[Stmt] = []
                 for s in f.body: body.push(self.transform_stmt(s))
                 orelse: Vec[Stmt] = []
                 for s in f.orelse: orelse.push(self.transform_stmt(s))
                 return Stmt.For(ast_create_for(box_expr(target), box_expr(iter), body, orelse))
                 
            case _:
                return stmt

    def transform_expr(self, expr: Expr) -> Expr:
        match expr:
            case Expr.Call(func=func_box, args=c_args, keywords=ckw):
                # Check func name
                func_expr = deref(func_box).clone()
                
                # We need to peek function name without consuming func_expr
                # But to transform/rebuild, we consume it?
                # We can check name if it is Name(n).
                func_name = ""
                has_name = False
                match func_expr:
                    case Expr.Name(n):
                        func_name = n.clone()
                        has_name = True
                        func_expr = Expr.Name(n) # Put it back
                    case _:
                        has_name = False
                        
                # Transform args
                new_args: Vec[Expr] = []
                if has_name:
                    pass
                
                # Transform func expression (e.g. methods)
                func_expr = self.transform_expr(func_expr)

                # Check signature
                sig: Vec[bool] = []
                if has_name and self.signatures.contains_key(ref(func_name)):
                    sig = self.signatures.get(ref(func_name)).unwrap().clone()
                
                idx = 0
                for arg in c_args:
                    arg_check = arg.clone()
                    new_arg = self.transform_expr(arg)
                    
                    if idx < sig.len():
                        needs_borrow = sig[idx]
                        if needs_borrow:
                            is_already_ref = False
                            match arg_check:
                                case Expr.Name(ncn):
                                    for ca in self.current_complex_args.clone():
                                        if ca == ncn: is_already_ref = True
                                case _: pass

                            if is_already_ref:
                                # Reborrow: mutref(deref(arg))
                                # Construct deref(arg)
                                d_func = box_expr(Expr.Name("deref".to_string()))
                                d_args: Vec[Expr] = []
                                d_args.push(new_arg)
                                deref_call = ast_create_call(d_func, d_args)
                                
                                # Wrap in mutref(...)
                                new_arg = deref(ast_wrap_mutref_call(box_expr(deref_call)))
                            else:
                                # Wrap (auto-borrow): mutref(arg)
                                new_arg = deref(ast_wrap_mutref_call(box_expr(new_arg)))
                    
                    new_args.push(new_arg)
                    idx = idx + 1
                
                # Transform keyword values (for struct constructors)
                is_struct_ctor = has_name and (func_name.len() > 0)
                if is_struct_ctor:
                    if check_first_upper(func_name.clone()):
                        is_struct_ctor = True
                    else:
                        is_struct_ctor = False
                
                new_keywords: Vec[Keyword] = []
                for kw in ckw:
                    kw_value = self.transform_expr(deref(kw.value).clone())
                    # For struct constructors, wrap Name expressions in deref() to clone
                    # but ONLY if the Name is in current_complex_args (auto-borrowed params)
                    if is_struct_ctor:
                        match ref(kw_value):
                            case Expr.Name(n):
                                # Check if this name is an auto-borrowed param
                                is_complex_arg = False
                                for ca in self.current_complex_args.clone():
                                    if ca == deref(n):
                                        is_complex_arg = True
                                if is_complex_arg:
                                    # Wrap with deref(...) to get owned value from &mut ref
                                    d_func = box_expr(Expr.Name("deref".to_string()))
                                    d_args: Vec[Expr] = []
                                    d_args.push(kw_value.clone())
                                    kw_value = ast_create_call(d_func, d_args)
                            case _:
                                pass
                    new_kw = ast_create_keyword(kw.arg.clone(), box_expr(kw_value))
                    new_keywords.push(new_kw)
                
                # Reconstruct Call with transformed keywords
                new_call = ast_create_call_with_keywords(box_expr(func_expr), new_args, new_keywords)

                # Wrap @extern calls that return Managed types
                if has_name and self.extern_returns.contains_key(ref(func_name)):
                     ret_type = self.extern_returns.get(ref(func_name)).unwrap().clone()
                     
                     # Check if we should wrap
                     should_wrap = False
                     # Don't wrap if already Managed, generic Handle, or Option
                     if not (check_prefix(ret_type.clone(), "Managed") or check_prefix(ret_type.clone(), "Handle") or check_prefix(ret_type.clone(), "Option")):
                          strategy = get_strategy_for_type(ref(self.memory_analyzer), ret_type.clone())
                          match strategy:
                               case AllocationStrategy.Managed: should_wrap = True
                               case _: pass
                     
                     if should_wrap:
                          managed_name = box_expr(create_name_expr("Managed"))
                          new_attr = ast_create_attribute(managed_name, "new".to_string())
                          wrapper_args: Vec[Expr] = []
                          wrapper_args.push(new_call)
                          kw_empty: Vec[Keyword] = []
                          return ast_create_call_with_keywords(box_expr(new_attr), wrapper_args, kw_empty)

                return new_call

            case Expr.Subscript(value=val_box, slice=slice_box):
                # value[slice]
                # Cast slice to usize (but NOT for Slice/range expressions)
                val = self.transform_expr(deref(val_box).clone())
                slice = self.transform_expr(deref(slice_box).clone())
                
                # Check if this is a Slice (range) expression - don't cast those
                is_slice_range = False
                match ref(slice):
                    case Expr.Slice(lower=l, upper=u, step=s):
                        is_slice_range = True
                    case _:
                        pass
                
                if is_slice_range:
                    # Don't cast Slice ranges to usize
                    return ast_create_subscript(box_expr(val), box_expr(slice))
                else:
                    # Auto-Cast normal indices to usize
                    new_slice = deref(ast_cast_usize(box_expr(slice)))
                    return ast_create_subscript(box_expr(val), box_expr(new_slice))

            case Expr.BinOp(left=l, op=o, right=r):
                new_l = self.transform_expr(deref(l).clone())
                new_r = self.transform_expr(deref(r).clone())
                return ast_create_binop(box_expr(new_l), o, box_expr(new_r))

            case Expr.UnaryOp(op=o, operand=opd):
                new_opd = self.transform_expr(deref(opd).clone())
                return ast_create_unaryop(o, box_expr(new_opd))

            case Expr.BoolOp(op=o, values=vals):
                new_vals: Vec[Expr] = []
                for v in vals: new_vals.push(self.transform_expr(v))
                return ast_create_boolop(o, new_vals)

            case Expr.List(elts):
                new_elts: Vec[Expr] = []
                for e in elts: new_elts.push(self.transform_expr(e))
                return ast_create_list(new_elts)

            case Expr.Name(n):
                 return Expr.Name(n)
            case Expr.Constant(c):
                 return Expr.Constant(c)
                 
            # Need to handle assignments constructs? (Assign uses Expr for targets?)
            # Assign struct has 'targets: Vec[Expr]'.
            # Stmt.Assign handles assignment.
            
            case Expr.Attribute(value=v, attr=a):
                 # Transform value recursively (e.g. sum([10]).to_string())
                 # inner sum call needs transform
                 new_v = self.transform_expr(deref(v).clone())
                 return ast_create_attribute(box_expr(new_v), a.to_string())

            case Expr.Tuple(elts):
                 new_elts: Vec[Expr] = []
                 for e in elts: new_elts.push(self.transform_expr(e))
                 return ast_create_tuple(new_elts)

            case _:
                return expr

@extern(path="crate::ast_create_binop")
def ast_create_binop(left: Box[Expr], op: Operator, right: Box[Expr]) -> Expr: pass

@extern(path="crate::ast_create_unaryop")
def ast_create_unaryop(op: UnaryOperator, operand: Box[Expr]) -> Expr: pass

@extern(path="crate::ast_create_boolop")
def ast_create_boolop(op: BoolOperator, values: Vec[Expr]) -> Expr: pass

@extern(path="crate::ast_create_list")
def ast_create_list(elts: Vec[Expr]) -> Expr: pass

@extern(path="crate::make_if_stmt")
def make_if_stmt(test: Box[Expr], body: Vec[Stmt], orelse: Vec[Stmt]) -> Stmt: pass

@extern(path="crate::make_while_stmt")
def make_while_stmt(test: Box[Expr], body: Vec[Stmt], orelse: Vec[Stmt]) -> Stmt: pass

@extern(path="crate::make_for_stmt")
def make_for_stmt(target: Box[Expr], iter: Box[Expr], body: Vec[Stmt], orelse: Vec[Stmt]) -> Stmt: pass

@extern(path="crate::ast_set_func_args")
def ast_set_func_args(f: FunctionDef, args: Vec[Arg]) -> FunctionDef: pass

@extern(path="crate::check_first_upper")
def check_first_upper(s: String) -> bool: pass

@extern(path="crate::check_prefix")
def check_prefix(s: String, prefix: String) -> bool: pass

@extern(path="crate::create_name_expr")
def create_name_expr(s: String) -> Expr: pass

@extern(path="crate::ast_create_assign")
def ast_create_assign(targets: Vec[Expr], value: Box[Expr]) -> Assign: pass

@extern(path="crate::ast_create_if")
def ast_create_if(test: Box[Expr], body: Vec[Stmt], orelse: Vec[Stmt]) -> IfStmt: pass

@extern(path="crate::ast_create_for")
def ast_create_for(target: Box[Expr], iter: Box[Expr], body: Vec[Stmt], orelse: Vec[Stmt]) -> ForStmt: pass

@extern(path="crate::ast_create_call")
def ast_create_call(func: Box[Expr], args: Vec[Expr]) -> Expr: pass

@extern(path="crate::ast_create_call_with_keywords")
def ast_create_call_with_keywords(func: Box[Expr], args: Vec[Expr], keywords: Vec[Keyword]) -> Expr: pass

@extern(path="crate::ast_create_keyword")
def ast_create_keyword(arg: Option[String], value: Box[Expr]) -> Keyword: pass

@extern(path="crate::ast_create_subscript")
def ast_create_subscript(value: Box[Expr], slice: Box[Expr]) -> Expr: pass

@extern(path="crate::ast_create_attribute")
def ast_create_attribute(value: Box[Expr], attr: String) -> Expr: pass

@extern(path="crate::ast_create_tuple")
def ast_create_tuple(elts: Vec[Expr]) -> Expr: pass


def transform_module(module: QuicheModule, verbose: bool) -> QuicheModule:
    t = create_Transformer()
    t.verbose = verbose
    return t.transform_module(module)
