@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def push_str(self, s: StrRef): pass

@extern(path="rustpython_parser::ParseError", no_generic=True)
class ParseError:
    pass

from compiler import Codegen

@extern(path="rustpython_parser::parse_program")
def parse_program(source: StrRef, filename: StrRef) -> Result[List[ast.Stmt], ParseError]:
    pass

# --- Main ---

def main():
    print("=== Quiche Self-Hosted Compiler Prototype ===")
    
    # Simple source code to compile
    source = "def foo():\n    x = 42\n    return x\n"
    
    print("Input Source:")
    print(source)
    print("---------------------------------------------")
    
    # Parse
    match parse_program(as_ref(source), as_ref("<embedded>")):
        case Ok(stmts):
            # Compile using modular Codegen
            codegen = Codegen.new()
            
            for stmt in stmts:
                codegen.generate_stmt(stmt)
                    
            print("Generated Rust Code:")
            print(codegen.output) 
            
        case Err(e):
            print("Parse Error")
