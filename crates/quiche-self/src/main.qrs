
from ast import Stmt, Parsed
from types import TypeChecker
from compiler.codegen import Codegen
from rust.parsley_qrs import Parsley

@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def push_str(self, s: StrRef): pass
    def clone(self) -> RustString: pass

@extern(path="ruff_python_parser::ParseError", no_generic=True)
class ParseError:
    pass

@extern(path="ruff_python_parser::parse_module")
def parse_module(source: StrRef) -> Result[Parsed, ParseError]:
    pass

@extern(path="crate::quiche::env_args_helper")
def env_args() -> List[String]: pass

@extern(path="std::fs::read_to_string")
def read_to_string(path: String) -> String: pass 

@extern(path="std::process::exit")
def exit(code: i32): pass

@extern(path="crate::quiche::path_dirname")
def path_dirname(path: String) -> String: pass

@extern(path="crate::quiche::build_module_index")
def build_module_index(root: String) -> Dict[String, String]: pass

@extern(path="crate::quiche::module_path_for_file")
def module_path_for_file(root: String, filename: String) -> String: pass

@extern(path="crate::quiche::module_parent")
def module_parent(path: String, levels: u32) -> String: pass

@extern(path="crate::quiche::dedup_shadowed_let_mut")
def dedup_shadowed_let_mut(code: String) -> String: pass

@extern(path="crate::quiche::module_join")
def module_join(base: String, sub: String) -> String: pass

@extern(path="crate::quiche::path_exists")
def path_exists(path: String) -> bool: pass

@extern(path="crate::quiche::create_dir_all")
def create_dir_all(path: String): pass

@extern(path="crate::quiche::write_string")
def write_string(path: String, contents: String): pass

@extern(path="crate::quiche::set_env_var")
def set_env_var(key: String, value: String): pass

@extern(path="crate::quiche::current_exe_path")
def current_exe_path() -> String: pass

@extern(path="crate::quiche::run_cargo_command")
def run_cargo_command(cmd: String, args: List[String]) -> i32: pass

@extern(path="crate::quiche::run_rust_code")
def run_rust_code(user_code: String, script_args: List[String], quiet: bool, suppress_output: bool, raw_output: bool, warn: bool, strict: bool) -> i32: pass

@extern(path="crate::quiche::compiler_path_for_new")
def compiler_path_for_new() -> String: pass

@extern(path="crate::quiche::print_stdout")
def print_stdout(s: String): pass

@extern(path="crate::version_info::get_stage")
def version_get_stage() -> String: pass

@extern(path="crate::version_info::get_commit")
def version_get_commit() -> String: pass

@extern(path="crate::version_info::get_date")
def version_get_date() -> String: pass

@extern(path="crate::version_info::get_build_kind")
def version_get_build_kind() -> String: pass

def get_flag_bool(flags: Dict[String, bool], key: String) -> bool:
    for k in flags.keys():
        if k == key:
            match flags.get(k):
                case Some(v): return v
                case None: pass
    return False


@extern(path="crate::quiche::vec_to_list")
def vec_to_list(v: List[Stmt]) -> List[Stmt]: pass 

@extern(path="parsley_qrs::ParseResult", no_generic=True)
class ParseResult:
    flags: Dict[String, bool]
    options: Dict[String, String]
    positionals: List[String]
    errors: List[String]
    command: String
    subargs: List[String]

class WarnFlags:
    warn: bool
    strict: bool
    warn_all: bool
    warn_quiche: bool

    def new(warn: bool, strict: bool, warn_all: bool, warn_quiche: bool) -> WarnFlags:
        return WarnFlags(warn=warn, strict=strict, warn_all=warn_all, warn_quiche=warn_quiche)


class ImportMaps:
    paths: Dict[String, String]
    kinds: Dict[String, String]

    def new(paths: Dict[String, String], kinds: Dict[String, String]) -> ImportMaps:
        return ImportMaps(paths=paths, kinds=kinds)


def module_to_rust_path(module_path: String) -> String:
    if module_path == "": return "crate"
    is_external = False
    res = module_path.clone()
    if res.starts_with(as_ref("rust.")):
        res = res.replace(as_ref("rust."), as_ref(""))
        is_external = True
    elif res.starts_with(as_ref("std.")):
        is_external = True
    if not is_external:
        res = "crate.".to_string() + as_ref(res)
    return res.replace(as_ref("."), as_ref("::"))


def resolve_module_path(current_module_path: String, module_name: String, level: u32) -> String:
    base = ""
    if level > 0:
        base = module_parent(current_module_path.clone(), level)
    if module_name == "":
        return base
    if base != "":
        return module_join(base, module_name)
    return module_name


def collect_module_exports(module_index: Dict[String, String], module_path: String) -> Dict[String, String]:
    exports = Dict[String, String].new()
    match module_index.get(module_path):
        case Some(path):
            source = read_to_string(path.clone())
            parsed = parse_module(source.as_str())
            module = parsed.into_syntax()
            for stmt in module.body:
                match stmt:
                    case Stmt.ClassDef(c):
                        exports.insert(c.name.as_str().to_string(), "class")
                    case Stmt.FunctionDef(f):
                        exports.insert(f.name.as_str().to_string(), "func")
                    case _: pass
        case None: pass
    return exports


def build_import_maps(stmts: List[Stmt], module_index: Dict[String, String], current_module_path: String) -> ImportMaps:
    import_paths = Dict[String, String].new()
    import_kinds = Dict[String, String].new()

    for stmt in stmts:
        match stmt:
            case Stmt.Import(i):
                for alias in i.names:
                    module_name = alias.name.as_str().to_string()
                    alias_name = module_name.clone()
                    match alias.asname.clone():
                        case Some(a): alias_name = a.as_str().to_string()
                        case None: pass
                    module_path = resolve_module_path(current_module_path.clone(), module_name, 0)
                    rust_path = module_to_rust_path(module_path)
                    import_paths.insert(alias_name.clone(), rust_path)
                    import_kinds.insert(alias_name.clone(), "module")
            case Stmt.ImportFrom(i):
                base_module = ""
                match i.module:
                    case Some(m):
                        if m.as_str().to_string() == "lib.test": continue
                        base_module = resolve_module_path(current_module_path.clone(), m.as_str().to_string(), i.level)
                    case None:
                        base_module = resolve_module_path(current_module_path.clone(), "", i.level)

                is_external = base_module.starts_with(as_ref("rust.")) or base_module.starts_with(as_ref("std."))
                exports = Dict[String, String].new()
                if not is_external:
                    match module_index.get(base_module.clone()):
                        case Some(_):
                            exports = collect_module_exports(module_index.clone(), base_module.clone())
                        case None: pass

                for alias in i.names:
                    name = alias.name.as_str().to_string()
                    alias_name = name.clone()
                    match alias.asname.clone():
                        case Some(a): alias_name = a.as_str().to_string()
                        case None: pass

                    kind = "value"
                    item_module = module_join(base_module.clone(), name.clone())
                    rust_path = ""
                    match module_index.get(item_module.clone()):
                        case Some(_):
                            kind = "module"
                            rust_path = module_to_rust_path(item_module)
                        case None:
                            rust_path = module_to_rust_path(base_module.clone())
                            rust_path = rust_path + as_ref("::")
                            rust_path = rust_path + as_ref(name)
                            if is_external:
                                kind = "module"
                            else:
                                match exports.get(name.clone()):
                                    case Some(k):
                                        if k == "class": kind = "type"
                                        elif k == "func": kind = "func"
                                        else: kind = "value"
                                    case None: kind = "value"

                    import_paths.insert(alias_name.clone(), rust_path)
                    import_kinds.insert(alias_name.clone(), kind)
            case _:
                pass

    return ImportMaps.new(import_paths, import_kinds)

def normalize_module_path(module_path: String) -> String:
    if module_path == "main" or module_path == "lib":
        return ""
    return module_path


# --- Main ---

def compile_source_to_string(source: String, filename: String, warn_quiche: bool, strict: bool) -> String:
    # Ruff parse_module does not take filename in simple API
    # check! macro unwraps Result automatically for us in host compiler
    parsed = parse_module(source.as_str())
    module = parsed.into_syntax()
    stmts = module.body

    root_dir = path_dirname(filename.clone())
    module_index = build_module_index(root_dir.clone())
    current_module_path = normalize_module_path(module_path_for_file(root_dir, filename.clone()))
    import_maps = build_import_maps(vec_to_list(stmts.clone()), module_index, current_module_path.clone())
    
    # Type Check
    checker = TypeChecker.new()
    for stmt in stmts.clone():
        checker.check_stmt(stmt)

    if warn_quiche and checker.warnings.len() > 0:
        print("Warnings:")
        for w in checker.warnings:
            print(w)
        if strict:
            exit(1)
    
    if checker.errors.len() > 0:
        print("Type Errors found:")
        for err in checker.errors:
            print(err)
        exit(1)
    else:
        # Codegen
        codegen = Codegen.new_with_imports_and_module(import_maps.paths, import_maps.kinds, current_module_path)
        for stmt in stmts:
            codegen.generate_stmt(stmt)
        
        cleaned = dedup_shadowed_let_mut(codegen.output)
        return cleaned

    return ""

def compile_source(source: String, filename: String, warn_quiche: bool, strict: bool):
    code = compile_source_to_string(source, filename, warn_quiche, strict)
    print_str(code)

def print_usage():
    print("Usage:")
    print("  quiche-self new <name>    Create a new Quiche project")
    print("  quiche-self build         Build the current project")
    print("  quiche-self run           Run the current project")
    print("  quiche-self test          Run project tests")
    print("  quiche-self <file.qrs>    Transpile a single file")
    print("")
    print("Flags:")
    print("  --warn               Show compiler warnings")
    print("  --strict             Treat warnings as errors")
    print("  --warn-all           Show all warnings (Quiche + Rust)")
    print("  --warn-quiche        Show only Quiche warnings")

def build_flag_parser(include_lib: bool) -> Parsley:
    parser = Parsley.new()
    parser.add_flag("warn-all", ["--warn"], False)
    parser.add_flag("warn-quiche", [], False)
    parser.add_flag("strict", [], False)
    parser.add_flag("emit-rust", [], False)
    if include_lib:
        parser.add_flag("lib", [], False)
    return parser

def parse_warn_flags(flags: Dict[String, bool]) -> WarnFlags:
    warn_all = False
    warn_quiche = False
    strict = False
    k1 = "warn-all"
    k1 = "warn-all"
    k1 = "warn-all"
    warn_all = get_flag_bool(flags.clone(), k1)
    k2 = "warn-quiche"
    warn_quiche = get_flag_bool(flags.clone(), k2)
    k3 = "strict"
    strict = get_flag_bool(flags.clone(), k3)
    warn = warn_all
    if warn_all:
        warn = True
    return WarnFlags.new(warn, strict, warn_all, warn_quiche)

def template_quiche_toml(name: String) -> String:
    return "[package]\nname = \"" + name.as_str() + as_ref("\"\nversion = \"0.1.0\"\n")

def template_cargo_toml(name: String, is_lib: bool, compiler_path: String) -> String:
    s = "[package]\nname = \"" + name.as_str() + as_ref("\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n")
    s = s + as_ref("# Break out of any parent workspace\n[workspace]\n\n")
    s = s + as_ref("[build-dependencies]\nquiche_compiler = { path = \"") + compiler_path.as_str() + as_ref("\" }\n\n")
    s = s + as_ref("[dependencies]\n")
    if is_lib:
        s = s + as_ref("\n[lib]\npath = \"src/lib.rs\"\n")
    else:
        s = s + as_ref("\n[[bin]]\nname = \"") + name.as_str() + as_ref("\"\npath = \"src/main.rs\"\n")
    return s

def template_build_rs() -> String:
    return "\nuse std::env;\nuse std::fs;\nuse std::path::Path;\nuse quiche_compiler::compile;\n\nfn main() {\n    println!(\"cargo:rerun-if-changed=src\");\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    \n    // Check for lib.qrs or main.qrs\n    let is_lib = Path::new(\"src/lib.qrs\").exists();\n    let source_path = if is_lib { \"src/lib.qrs\" } else { \"src/main.qrs\" };\n    let dest_name = if is_lib { \"lib.rs\" } else { \"main.rs\" };\n    let dest_path = Path::new(&out_dir).join(dest_name);\n\n    if Path::new(source_path).exists() {\n        let source = fs::read_to_string(source_path).expect(\"Read source failed\");\n        let source = source.replace(\"struct \", \"class \");\n        \n        if let Some(rust_code) = compile(&source) {\n            fs::write(&dest_path, rust_code).expect(\"Write output failed\");\n        } else {\n            panic!(\"Compilation failed\");\n        }\n    } else {\n        fs::write(&dest_path, \"\").unwrap();\n    }\n}\n"

def template_lib_qrs() -> String:
    return "\ndef hello():\n    print(\"Hello from Lib!\")\n"

def template_lib_rs() -> String:
    return "\n#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]\n\nmod quiche {\n    #![allow(unused_macros, unused_imports)]\n    \n    // High Priority: Consumes Self (Result/Option)\n    pub trait QuicheResult {\n        type Output;\n        fn quiche_handle(self) -> Self::Output;\n    }\n    \n    impl<T, E: std::fmt::Debug> QuicheResult for Result<T, E> {\n        type Output = T;\n        fn quiche_handle(self) -> T {\n            self.expect(\"Quiche Exception\")\n        }\n    }\n    \n\n    \n    // Low Priority: Takes &Self (Clone fallback)\n    pub trait QuicheGeneric {\n        fn quiche_handle(&self) -> Self;\n    }\n    \n    impl<T: Clone> QuicheGeneric for T {\n        fn quiche_handle(&self) -> Self {\n            self.clone()\n        }\n    }\n\n    macro_rules! check {\n        ($val:expr) => {\n            {\n                use crate::quiche::{QuicheResult, QuicheGeneric};\n                ($val).quiche_handle()\n            }\n        };\n    }\n    pub(crate) use check;\n    pub(crate) use check as call;\n}\n\n// Re-export everything from the transpiled module\ninclude!(concat!(env!(\"OUT_DIR\"), \"/lib.rs\"));\n"

def template_main_qrs() -> String:
    return "\ndef main():\n    print(\"Hello, Quiche!\")\n"

def template_main_rs() -> String:
    return "\n#![allow(dead_code, unused_variables, unused_mut, unused_imports, unused_parens)]\n\nmod quiche {\n    #![allow(unused_macros, unused_imports)]\n    \n    // High Priority: Consumes Self (Result/Option)\n    pub trait QuicheResult {\n        type Output;\n        fn quiche_handle(self) -> Self::Output;\n    }\n    \n    impl<T, E: std::fmt::Debug> QuicheResult for Result<T, E> {\n        type Output = T;\n        fn quiche_handle(self) -> T {\n            self.expect(\"Quiche Exception\")\n        }\n    }\n    \n\n    \n    // Low Priority: Takes &Self (Clone fallback)\n    pub trait QuicheGeneric {\n        fn quiche_handle(&self) -> Self;\n    }\n    \n    impl<T: Clone> QuicheGeneric for T {\n        fn quiche_handle(&self) -> Self {\n            self.clone()\n        }\n    }\n\n    macro_rules! check {\n        ($val:expr) => {\n            {\n                use crate::quiche::{QuicheResult, QuicheGeneric};\n                ($val).quiche_handle()\n            }\n        };\n    }\n    pub(crate) use check;\n    pub(crate) use check as call;\n}\n\ninclude!(concat!(env!(\"OUT_DIR\"), \"/main.rs\"));\n"

def create_new_project(name: String, is_lib: bool):
    if path_exists(name.clone()):
        print(f"Error: Directory '{name}' already exists")
        return

    create_dir_all(name.clone() + as_ref("/src"))
    write_string(name.clone() + as_ref("/Quiche.toml"), template_quiche_toml(name.clone()))
    compiler_path = compiler_path_for_new()
    write_string(name.clone() + as_ref("/Cargo.toml"), template_cargo_toml(name.clone(), is_lib, compiler_path))
    write_string(name.clone() + as_ref("/build.rs"), template_build_rs())

    if is_lib:
        write_string(name.clone() + as_ref("/src/lib.qrs"), template_lib_qrs())
        write_string(name.clone() + as_ref("/src/lib.rs"), template_lib_rs())
    else:
        write_string(name.clone() + as_ref("/src/main.qrs"), template_main_qrs())
        write_string(name.clone() + as_ref("/src/main.rs"), template_main_rs())

    print(f"Created new project: {name}")

def run_transpiled_file(filename: String, script_args: List[String], quiet: bool, suppress_output: bool, raw_output: bool, warn: bool, strict: bool, warn_quiche: bool):
    source = read_to_string(filename.clone())
    rust_code = compile_source_to_string(source, filename.clone(), warn_quiche, strict)
    exit_code = run_rust_code(rust_code, script_args, quiet, suppress_output, raw_output, warn, strict)
    if exit_code != 0:
        exit(exit_code)

def main():
    cli_args: List[String] = env_args()
    args: List[String] = []
    i = 0
    for arg in cli_args:
        if i > 0:
            args.append(arg)
        i = i + 1

    if len(args) == 0:
        print("Error: No command specified.")
        print_usage()
        exit(1)

    commands = ["new", "build", "run", "test", "version"]
    cmd = args[0].clone()
    has_command = False
    for c in commands:
        if c == cmd:
            has_command = True

    if has_command:
        subargs: List[String] = []
        j = 1
        while j < len(args):
            subargs.push(args[j].clone())
            j = j + 1

        if cmd == "new":
            parser = build_flag_parser(True)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            if len(result.positionals) < 1:
                print("Error: Missing project name.")
                print("Usage: quiche-self new [--lib] <project_name>")
                exit(1)
            name = result.positionals[0].clone()
            is_lib = False
            k_lib = "lib"
            k_lib = "lib"
            is_lib = get_flag_bool(result.flags.clone(), k_lib)
            create_new_project(name, is_lib)
            return

        if cmd == "build":
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            exit_code = run_cargo_command("build".to_string(), result.positionals)
            if exit_code != 0:
                exit(exit_code)
            return

        if cmd == "run":
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            if path_exists("Cargo.toml"):
                exit_code = run_cargo_command("run".to_string(), result.positionals)
                if exit_code != 0:
                    exit(exit_code)
            else:
                print("Error: No Cargo.toml found in current directory.")
                print("To run a single script, use: quiche-self <file.qrs>")
                exit(1)
            return

        if cmd == "test":
            parser = build_flag_parser(False)
            result = parser.parse(subargs)
            if result.errors.len() > 0:
                for e in result.errors:
                    print(e)
                print_usage()
                exit(1)
            flags = parse_warn_flags(result.flags.clone())
            if flags.warn_all:
                flags.warn_quiche = True
            if path_exists("tests/runner.qrs"):
                exe = current_exe_path()
                if exe != "":
                    set_env_var("QUICHE_TEST_BIN", exe)
                if flags.warn_all:
                    set_env_var("QUICHE_WARN_ALL", "1")
                if flags.warn_quiche:
                    set_env_var("QUICHE_WARN_QUICHE", "1")
                run_transpiled_file("tests/runner.qrs", result.positionals, True, False, True, flags.warn, flags.strict, flags.warn_quiche)
            elif path_exists("Cargo.toml"):
                exit_code = run_cargo_command("test".to_string(), result.positionals)
                if exit_code != 0:
                    exit(exit_code)
            else:
                print("Error: No tests/runner.qrs or Cargo.toml found.")
                exit(1)
            return
        
        if cmd == "version":
            stage = version_get_stage()
            commit = version_get_commit()
            date = version_get_date()
            kind = version_get_build_kind()
            
            print(f"compiler path/name: {stage}")
            print(f"active version stage: {stage}")
            print(f"commit #: {commit}")
            print(f"datetime of build: {date}")
            print(f"build kind: {kind}")
            return

    if cmd.ends_with(as_ref(".qrs")):
        if not path_exists(cmd.clone()):
            print(f"Error: File '{cmd}' not found.")
            exit(1)
        parser = build_flag_parser(False)
        rest: List[String] = []
        k = 1
        while k < len(args):
            rest.append(args[k].clone())
            k = k + 1
        result = parser.parse(rest)
        if result.errors.len() > 0:
            for e in result.errors:
                print(e)
            print_usage()
            exit(1)
        flags = parse_warn_flags(result.flags.clone())
        
        emit_rust = False
        k_er = "emit-rust"
        k_er = "emit-rust"
        emit_rust = get_flag_bool(result.flags.clone(), k_er)

        if emit_rust:
             source = read_to_string(cmd.clone())
             code = compile_source_to_string(source, cmd.clone(), flags.warn_quiche, flags.strict)
             print_stdout(code)
             return

        if flags.warn_all:
            flags.warn_quiche = True
        run_transpiled_file(cmd.clone(), result.positionals, True, False, True, flags.warn, flags.strict, flags.warn_quiche)
        return

    print(f"Error: Unrecognized command or file '{cmd}'")
    print("")
    print_usage()
    exit(1)
