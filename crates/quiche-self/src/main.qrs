
import ast
import types
from compiler import Codegen

@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def push_str(self, s: StrRef): pass

@extern(path="rustpython_parser::ParseError", no_generic=True)
class ParseError:
    pass

@extern(path="rustpython_parser::parse_program")
def parse_program(source: StrRef, filename: StrRef) -> Result[List[ast.Stmt], ParseError]:
    pass

# --- Main ---

def main():
    print("=== Quiche Self-Hosted Compiler Prototype ===")
    
    # Simple source code to compile
    source = "def foo():\n    x = 42\n    return x\n"
    
    print("Input Source:")
    print(source)
    print("---------------------------------------------")
    
    # Parse
    match parse_program(as_ref(source), as_ref("<embedded>")):
        case Ok(stmts):
              # Type Check
            checker = types.TypeChecker.new()
            for stmt in as_ref(stmts):
                checker.check_stmt(stmt)
            
            if checker.errors.len() > 0:
                print("Type Errors found:")
                for err in checker.errors:
                    print(err)
            else:
                print("Type Check Passed")
                
                # Codegen
                codegen = compiler.Codegen.new()
                for stmt in stmts:
                    codegen.generate_stmt(stmt)
                    
                print("Generated Rust Code:")
                print(codegen.output) 
            
        case Err(e):
            print("Parse Error")
