
import ast
import types
from compiler import Codegen

@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def push_str(self, s: StrRef): pass
    def clone(self) -> RustString: pass

@extern(path="ruff_python_parser::ParseError", no_generic=True)
class ParseError:
    pass

@extern(path="ruff_python_parser::parse_module")
def parse_module(source: StrRef) -> Result[ast.Parsed, ParseError]:
    pass

@extern(path="crate::quiche::env_args_helper")
def env_args() -> List[String]: pass

@extern(path="std::fs::read_to_string")
def read_to_string(path: String) -> String: pass 

@extern(path="std::process::exit")
def exit(code: i32): pass


# --- Main ---

def compile_source(source: String, filename: String):
    # Ruff parse_module does not take filename in simple API
    # check! macro unwraps Result automatically for us in host compiler
    parsed = parse_module(as_ref(source))
    module = parsed.into_syntax()
    stmts = module.body
    
    # Type Check
    checker = types.TypeChecker.new()
    for stmt in as_ref(stmts):
        checker.check_stmt(stmt)
    
    if checker.errors.len() > 0:
        print("Type Errors found:")
        for err in checker.errors:
            print(err)
        exit(1)
    else:
        # Codegen
        codegen = compiler.Codegen.new()
        for stmt in stmts:
            codegen.generate_stmt(stmt)
            
        print_str(codegen.output)

def main():
    cli_args = env_args()
    
    if cli_args.len() > 1:
        # Clone manually to avoid Host Compiler confusion on cli_args[1].clone()
        filename = RustString.clone(as_ref(cli_args[1]))
        
        # auto-unwraps (panics) on error due to Host Compiler check! macro
        source = read_to_string(filename.clone()) 
        compile_source(source, filename)
    else:
        print("Usage: quiche_self <file.qrs>")
        print("Running default demo...")
        demo_source = "def foo():\n    x = 42\n    return x\n"
        compile_source(demo_source, "<demo>")
