
import ast

# Dict is handled as a built-in mapping to HashMap in the host compiler.
# No need for @extern class Dict because it and its methods (get, insert) are whitelisted.

class Symbol:
    name: String
    type_name: String
    is_const: bool
    is_class: bool
    is_extern: bool
    is_module: bool

    def new(name: String, type_name: String, is_const: bool, is_class: bool, is_extern: bool, is_module: bool) -> Symbol:
        return Symbol(name=name, type_name=type_name, is_const=is_const, is_class=is_class, is_extern=is_extern, is_module=is_module)

    def var(name: String, type_name: String) -> Symbol:
        return Symbol.new(name, type_name, False, False, False, False)

    def func(name: String, is_extern: bool) -> Symbol:
        return Symbol.new(name, "function", True, False, is_extern, False)

    def clazz(name: String, is_extern: bool) -> Symbol:
        return Symbol.new(name.clone(), name, True, True, is_extern, False)

    def module(name: String) -> Symbol:
        return Symbol.new(name, "module", True, False, False, True)
    
    def imported(name: String) -> Symbol:
        return Symbol.new(name, "imported", True, True, True, False)

class SymbolTable:
    scopes: List[Dict[String, Symbol]]

    def new() -> SymbolTable:
        # Host compiler maps Dict[K, V] to HashMap<K, V>
        dict = Dict[String, Symbol].new()
        scopes = [dict]
        return SymbolTable(scopes=scopes)

    def enter_scope(self):
        self.scopes.push(Dict[String, Symbol].new())

    def exit_scope(self):
        sz = self.scopes.len()
        if sz > 1:
            self.scopes.pop()

    def insert(self, name: String, symbol: Symbol):
        # Insert into current (top) scope
        # Extract index to a local to avoid borrow conflict in generated Rust code
        sz = self.scopes.len()
        idx = sz - 1
        current_scope = as_mut(self.scopes[idx])
        current_scope.insert(name, symbol)

    def lookup(self, name: String) -> Option[Symbol]:
        # Search from inner to outer
        i = self.scopes.len()
        while i > 0:
            i = i - 1
            scope = as_ref(self.scopes[i])
            match scope.get(name):
                case Some(s):
                    return Some(s)
                case None:
                    pass
        return None

class TypeChecker:
    symbols: SymbolTable
    errors: List[String]
    warnings: List[String]

    def new() -> TypeChecker:
        return TypeChecker(symbols=SymbolTable.new(), errors=[], warnings=[])

    def check_stmt(self, stmt: ast.Stmt):
        match stmt:
            case ast.Stmt.FunctionDef(f):
                self.symbols.insert(f.name.as_str().to_string(), Symbol.new(f.name.as_str().to_string(), "function", True, False, False, False))
                self.symbols.enter_scope()
                # Register args
                # Register args
                for arg_with_default in f.parameters.args:
                    arg = arg_with_default.parameter
                    match arg.annotation:
                        case Some(ann):
                            type_name = self.get_type_name(deref(ann))
                            self.symbols.insert(arg.name.as_str().to_string(), Symbol.new(arg.name.as_str().to_string(), type_name, False, False, False, False))
                        case None:
                            self.warnings.push("Missing type annotation for argument")
                
                for s in f.body:
                    self.check_stmt(s)
                self.symbols.exit_scope()

            case ast.Stmt.Assign(a):
                # Simple single target
                match as_ref(a.targets[0]):
                    case ast.Expr.Name(n):
                        val_type = self.check_expr(deref(a.value))
                        self.symbols.insert(n.id.as_str().to_string(), Symbol.new(n.id.as_str().to_string(), val_type, False, False, False, False))
                    case _:
                        pass
            
            case ast.Stmt.Expr(e):
                self.check_expr(deref(e.value))
            
            case _:
                pass

    def check_expr(self, expr: ast.Expr) -> String:
        match expr:
            case ast.Expr.NumberLiteral(_):
                return "int"
            case ast.Expr.StringLiteral(_):
                return "String"
            case ast.Expr.BooleanLiteral(_):
                return "bool"
            case ast.Expr.Name(n):
                match self.symbols.lookup(n.id.as_str().to_string()):
                    case Some(s):
                        return s.type_name
                    case None:
                        self.errors.push("Undefined variable: " + as_ref(n.id.as_str().to_string()))
                        return "error"
            case _:
                return "unknown"

    def get_type_name(self, expr: ast.Expr) -> String:
        match expr:
            case ast.Expr.Name(n):
                return n.id.as_str().to_string()
            case _:
                return "complex"

class UsageInfo:
    last_use_idx: i32
    is_mutated: bool

    def new(idx: i32, is_mut: bool) -> UsageInfo:
        return UsageInfo(last_use_idx=idx, is_mutated=is_mut)
