import ast
import types
from compiler.extern_defs import RustString, q_push, escape_rust_string, vec_to_list
from compiler.codegen.state import CodegenState

def generate_expr(state: CodegenState, expr: ast.Expr):
    match expr:
        case ast.Expr.NumberLiteral(n): emit_number_literal(state, n)
        case ast.Expr.StringLiteral(s): emit_string_literal(state, s)
        case ast.Expr.BooleanLiteral(b): emit_boolean_literal(state, b)
        case ast.Expr.NoneLiteral(_): state.emit("None")
        case ast.Expr.Name(n):
            name_str = n.id.as_str().to_string()
            if state.is_type_or_mod(name_str.clone()):
                state.emit(name_str)
            else:
                match state.usage_ledger.get(name_str.clone()):
                    case Some(info):
                        is_terminal = (info.last_use_idx == state.current_stmt_idx)
                        if is_terminal:
                            state.emit(name_str)
                        else:
                            if state.clone_names:
                                state.emit(name_str)
                                state.emit(".clone()")
                            elif info.is_mutated:
                                state.emit("&mut ")
                                state.emit(name_str)
                            else:
                                state.emit("&")
                                state.emit(name_str)
                    case None:
                        if state.clone_names:
                            state.emit(name_str)
                            state.emit(".clone()")
                        else:
                            state.emit(name_str)
        case ast.Expr.Call(c): emit_call(state, c)
        case ast.Expr.List(l): emit_list(state, l)
        case ast.Expr.BinOp(b): emit_bin_op(state, b)
        case ast.Expr.BoolOp(b): emit_bool_op(state, b)
        case ast.Expr.UnaryOp(u): emit_unary_op(state, u)
        case ast.Expr.If(i): emit_expr_if(state, i)
        case ast.Expr.Compare(c): emit_compare(state, c)
        case ast.Expr.Tuple(t): emit_expr_tuple(state, t)
        case ast.Expr.Attribute(a): emit_attribute(state, a)
        case ast.Expr.Subscript(s): emit_subscript(state, s)
        case ast.Expr.Lambda(l): emit_lambda(state, l)
        case ast.Expr.FString(f): emit_fstring(state, f)
        case ast.Expr.Dict(d): emit_dict(state, d)
        case _: state.emit("/* expr */")

def generate_expr_no_clone(state: CodegenState, expr: ast.Expr):
    prev = state.clone_names
    state.clone_names = False
    generate_expr(state, expr)
    state.clone_names = prev

def emit_pattern_path(state: CodegenState, expr: ast.Expr):
    match expr:
        case ast.Expr.Name(n):
            state.emit(n.id.as_str().to_string())
        case ast.Expr.Attribute(a):
            emit_pattern_path(state, deref(a.value.clone()))
            state.emit("::")
            state.emit(a.attr.as_str().to_string())
        case _:
            generate_expr(state, expr)

def emit_lvalue_target(state: CodegenState, expr: ast.Expr):
    match expr:
        case ast.Expr.Name(n):
            state.emit(n.id.as_str().to_string())
        case ast.Expr.Subscript(s):
            emit_lvalue_target(state, deref(s.value.clone()))
            state.emit("[")
            lvalue_slice_is_string = False
            match deref(s.slice.clone()):
                case ast.Expr.StringLiteral(_): lvalue_slice_is_string = True
                case _: pass
            if lvalue_slice_is_string:
                state.emit("&")
            generate_expr(state, deref(s.slice.clone()))
            state.emit("]")
        case ast.Expr.Attribute(a):
            emit_lvalue_target(state, deref(a.value.clone()))
            state.emit(".")
            state.emit(a.attr.as_str().to_string())
        case _:
            generate_expr_no_clone(state, expr)

def emit_number_literal(state: CodegenState, n: ast.ExprNumberLiteral):
    match n.value:
        case ast.Number.Int(i):
            state.emit(i.to_string())
        case ast.Number.Float(f):
            s_f = f.to_string()
            if not s_f.contains(as_ref(".")):
               s_f = s_f + as_ref(".0")
            state.emit(s_f)
        case _: state.emit("0")

def emit_string_literal(state: CodegenState, s: ast.ExprStringLiteral):
    state.emit("String::from(\"")
    esc = escape_rust_string(s.value.to_string())
    state.emit(esc)
    state.emit("\")")

def emit_boolean_literal(state: CodegenState, b: ast.ExprBooleanLiteral):
    if b.value: state.emit("true")
    else: state.emit("false")

def emit_call(state: CodegenState, c: ast.ExprCall):
    func_name = ""
    match as_ref(deref(c.func)):
        case ast.Expr.Lambda(_):
            generate_expr(state, deref(c.func))
            state.emit("(")
            idx_lc = 0
            for arg in c.arguments.args:
                if idx_lc > 0: state.emit(", ")
                generate_expr(state, arg)
                idx_lc = idx_lc + 1
            state.emit(")")
            return
        case _: pass
    match as_ref(deref(c.func)):
        case ast.Expr.Name(n):
            func_name = n.id.as_str().to_string()
        case _: pass

    if func_name == "as_ref":
        if c.arguments.args.len() > 0:
            state.emit("&")
            generate_expr_no_clone(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
        return
    if func_name == "as_mut":
        if c.arguments.args.len() > 0:
            state.emit("&mut ")
            generate_expr_no_clone(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
        return
    if func_name == "deref":
        if c.arguments.args.len() > 0:
            state.emit("*")
            generate_expr_no_clone(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
        return
    if func_name == "exit":
        state.emit("std::process::exit(")
        idx_exit: usize = 0
        for arg in c.arguments.args:
            if idx_exit > 0: state.emit(", ")
            generate_expr(state, arg)
            idx_exit = idx_exit + 1
        state.emit(")")
        return

    if func_name == "print":
        state.emit("println!(\"{}\", ")
        first_p = True
        for arg in c.arguments.args:
            if not first_p: state.emit(", ")
            first_p = False
            generate_expr(state, arg)
        state.emit(")")
    elif func_name == "print_str":
        state.emit("println!(\"{}\", ")
        first_ps = True
        for arg in c.arguments.args:
            if not first_ps: state.emit(", ")
            first_ps = False
            generate_expr(state, arg)
        state.emit(")")
    elif func_name == "len":
        if c.arguments.args.len() == 1:
            target_len = ast.Expr.clone(as_ref(c.arguments.args[0]))
            generate_expr(state, target_len.clone())
            len_is_list = state.is_list_like_expr(target_len.clone())
            len_is_dict = state.is_dict_like_expr(target_len.clone())
            len_is_attr = False
            match as_ref(c.arguments.args[0]):
                case ast.Expr.Attribute(_): len_is_attr = True
                case ast.Expr.Subscript(_): len_is_attr = True
                case _: pass
            if len_is_list or len_is_dict or len_is_attr:
                state.emit(".len()")
            else:
                state.emit(".len()")
        else: state.emit("0")
    elif func_name == "assert_eq" or func_name == "assert_str_eq":
        state.emit("assert_eq!(")
        if c.arguments.args.len() >= 2:
            generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
            state.emit(", ")
            generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[1])))
            if c.arguments.args.len() > 2:
                state.emit(", \"{:?}\", ")
                generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[2])))
        state.emit(")")
    elif func_name == "assert_true":
        state.emit("assert!(")
        if c.arguments.args.len() >= 1:
            generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
            if c.arguments.args.len() > 1:
                state.emit(", \"{:?}\", ")
                generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[1])))
        state.emit(")")
    elif func_name == "range":
        if c.arguments.args.len() == 1:
            state.emit("0..")
            generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
        elif c.arguments.args.len() >= 2:
            generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[0])))
            state.emit("..")
            generate_expr(state, ast.Expr.clone(as_ref(c.arguments.args[1])))
    elif c.arguments.keywords.len() > 0:
        generate_expr(state, deref(c.func))
        state.emit(" { ")
        i_kw: usize = 0
        for kw in c.arguments.keywords:
            if i_kw > 0: state.emit(", ")
            match kw.arg:
                case Some(arg_id):
                    state.emit(arg_id.as_str().to_string())
                    state.emit(": ")
                    generate_expr(state, ast.Expr.clone(as_ref(kw.value)))
                case None: pass
            i_kw = i_kw + 1
        state.emit(" }")
    else:
        match as_ref(deref(c.func)):
            case ast.Expr.Attribute(at):
                is_static_call = False
                match state.get_root_name(ast.Expr.clone(as_ref(deref(at.value)))):
                    case Some(root_name):
                        if state.is_type_or_mod(root_name.clone()):
                            is_static_call = True
                        else:
                            match state.symbols.lookup(root_name):
                                case Some(s):
                                    if s.is_class or s.is_extern:
                                        is_static_call = True
                                case None: pass
                    case None: pass
                if at.attr.as_str().to_string() == "new": is_static_call = True

                if is_static_call:
                    attr_name_inner = at.attr.as_str().to_string()
                    if attr_name_inner == "new":
                        match as_ref(deref(at.value)):
                            case ast.Expr.Name(n):
                                base_name = n.id.as_str().to_string()
                                if base_name == "List" or base_name == "Vec":
                                    state.emit("std::rc::Rc::new(Vec::new())")
                                    return
                                if base_name == "Dict" or base_name == "HashMap":
                                    state.emit("std::rc::Rc::new(std::collections::HashMap::new())")
                                    return
                            case ast.Expr.Subscript(s):
                                base_name_s = state.type_to_string(ast.Expr.clone(as_ref(deref(s.value))))
                                if base_name_s == "Vec":
                                    inner_s = state.type_to_string(ast.Expr.clone(as_ref(deref(s.slice))))
                                    state.emit("std::rc::Rc::new(Vec::<")
                                    state.emit(inner_s)
                                    state.emit(">::new())")
                                    return
                                if base_name_s == "std::collections::HashMap":
                                    match as_ref(deref(s.slice)):
                                        case ast.Expr.Tuple(t):
                                            if t.elts.len() == 2:
                                                k_s = state.type_to_string(t.elts[0].clone())
                                                v_s = state.type_to_string(t.elts[1].clone())
                                                state.emit("std::rc::Rc::new(std::collections::HashMap::<")
                                                state.emit(k_s)
                                                state.emit(", ")
                                                state.emit(v_s)
                                                state.emit(">::new())")
                                                return
                                        case _: pass
                                    state.emit("std::rc::Rc::new(std::collections::HashMap::new())")
                                    return
                            case _: pass

                    if attr_name_inner == "clone":
                        generate_expr(state, deref(c.func))
                        state.emit("(")
                        idx_arg_s = 0
                        for arg_c in c.arguments.args.clone():
                            if idx_arg_s > 0: state.emit(", ")
                            generate_expr(state, arg_c)
                            idx_arg_s = idx_arg_s + 1
                        state.emit(")")
                    else:
                        state.emit("quiche_runtime::check!(quiche_runtime::call!(")
                        generate_expr_no_clone(state, deref(c.func))
                        for arg_c in c.arguments.args.clone():
                            state.emit(", ")
                            generate_expr(state, arg_c)
                        state.emit("))")
                else:
                    # Method call on an instance
                    attr_name_inner = at.attr.as_str().to_string()
                    receiver_expr = ast.Expr.clone(as_ref(deref(at.value)))
                    if attr_name_inner != "clone":
                        state.emit("quiche_runtime::check!(")
                    
                    is_list_receiver = state.is_list_like_expr(receiver_expr.clone())
                    is_dict_receiver = state.is_dict_like_expr(receiver_expr.clone())
                    if not is_dict_receiver:
                        # Heuristic for known dict vars
                        match receiver_expr.clone():
                            case ast.Expr.Name(n):
                                id_str = n.id.as_str().to_string()
                                if (id_str == "exports") or (id_str == "module_index") or (id_str == "flags") or (id_str == "import_paths") or (id_str == "import_kinds") or (id_str == "tuple_vars") or (id_str == "class_fields") or (id_str == "usage_ledger") or (id_str == "symbols"):
                                    is_dict_receiver = True
                            case ast.Expr.Attribute(a):
                                attr_str = a.attr.as_str().to_string()
                                if (attr_str == "tuple_vars") or (attr_str == "class_fields") or (attr_str == "usage_ledger") or (attr_str == "symbols") or (attr_str == "import_paths") or (attr_str == "import_kinds"):
                                    is_dict_receiver = True
                            case ast.Expr.Subscript(s):
                               match as_ref(deref(s.value)):
                                   case ast.Expr.Attribute(sa):
                                       if sa.attr.as_str().to_string() == "defined_vars": is_dict_receiver = True
                                   case ast.Expr.Name(sn):
                                       if sn.id.as_str().to_string() == "defined_vars": is_dict_receiver = True
                                   case _: pass
                            case _: pass
                    
                    if attr_name_inner == "len" and (is_list_receiver or is_dict_receiver):
                        generate_expr_no_clone(state, ast.Expr.clone(as_ref(deref(at.value))))
                        state.emit(".len()")
                        state.emit(")")
                        return

                    key_needs_ref = False
                    if is_dict_receiver:
                        if attr_name_inner == "get": key_needs_ref = True
                        if attr_name_inner == "remove": key_needs_ref = True
                        if attr_name_inner == "contains_key": key_needs_ref = True
                        if attr_name_inner == "pop": key_needs_ref = True

                    is_list_method = False
                    if attr_name_inner == "append": is_list_method = True
                    elif attr_name_inner == "pop": is_list_method = True
                    elif attr_name_inner == "push": is_list_method = True
                    elif attr_name_inner == "clear": is_list_method = True
                    elif attr_name_inner == "reverse": is_list_method = True
                    elif attr_name_inner == "sort": is_list_method = True
                    elif attr_name_inner == "insert": is_list_method = True
                    elif attr_name_inner == "extend": is_list_method = True

                    is_dict_mut = False
                    if attr_name_inner == "insert": is_dict_mut = True
                    elif attr_name_inner == "remove": is_dict_mut = True
                    elif attr_name_inner == "clear": is_dict_mut = True
                    elif attr_name_inner == "update": is_dict_mut = True
                    elif attr_name_inner == "pop": is_dict_mut = True

                    is_mut_call = is_list_method or is_dict_mut

                    is_symbols_receiver = False
                    match receiver_expr.clone():
                        case ast.Expr.Name(n):
                            if n.id.as_str().to_string() == "symbols": is_symbols_receiver = True
                        case ast.Expr.Attribute(a):
                            if a.attr.as_str().to_string() == "symbols": is_symbols_receiver = True
                        case _: pass

                    if is_mut_call:
                        if is_symbols_receiver:
                            state.emit("&mut ")
                            emit_lvalue_target(state, deref(at.value.clone()))
                        else:
                            state.emit("std::rc::Rc::make_mut(&mut ")
                            emit_lvalue_target(state, deref(at.value.clone()))
                            state.emit(")")
                    else:
                         old_cn = state.clone_names
                         if attr_name_inner == "clone": state.clone_names = True
                         if attr_name_inner == "clone":
                             generate_expr(state, ast.Expr.clone(as_ref(deref(at.value))))
                         else:
                             # Use emit_lvalue_target to avoid spurious & prefix on receivers
                             emit_lvalue_target(state, ast.Expr.clone(as_ref(deref(at.value))))
                         if attr_name_inner == "clone": state.clone_names = old_cn

                    state.emit(".")

                    if is_list_method and is_list_receiver:
                        if attr_name_inner == "append": state.emit("push(")
                        elif attr_name_inner == "pop": state.emit("pop(")
                        elif attr_name_inner == "push": state.emit("push(")
                        else:
                            state.emit(attr_name_inner.clone())
                            state.emit("(")
                    elif is_dict_receiver and attr_name_inner == "items":
                        state.emit("iter(")
                    elif attr_name_inner == "append":
                        # Always translate .append to .push for Rust Vecs
                        state.emit("push(")
                    else:
                        state.emit(attr_name_inner.clone())
                        state.emit("(")

                    idx_arg_m = 0
                    for arg in c.arguments.args.clone():
                        if idx_arg_m > 0: state.emit(", ")
                        # Skip adding & if arg is already as_ref() call
                        arg_is_ref = False
                        match arg.clone():
                            case ast.Expr.Call(ac):
                                match deref(ac.func.clone()):
                                    case ast.Expr.Name(n):
                                        if n.id.as_str().to_string() == "as_ref": arg_is_ref = True
                                    case _: pass
                            case _: pass
                        if key_needs_ref and idx_arg_m == 0 and not arg_is_ref: state.emit("&")
                        generate_expr(state, arg)
                        idx_arg_m = idx_arg_m + 1
                    state.emit(")")
                    if is_dict_receiver and attr_name_inner == "get": state.emit(".cloned()")
                    if attr_name_inner != "clone":
                        state.emit(")")
            case _:
                state.emit("quiche_runtime::check!(quiche_runtime::call!(")
                generate_expr_no_clone(state, deref(c.func))
                for arg_c in c.arguments.args.clone():
                    state.emit(", ")
                    generate_expr(state, arg_c)
                state.emit("))")

def emit_list(state: CodegenState, l: ast.ExprList):
    state.emit("std::rc::Rc::new(vec![")
    idx_l: usize = 0
    for e in l.elts:
        if idx_l > 0: state.emit(", ")
        generate_expr(state, e)
        idx_l = idx_l + 1
    state.emit("])")

def emit_bin_op(state: CodegenState, b: ast.ExprBinOp):
    generate_expr(state, deref(b.left))
    match b.op:
        case ast.Operator.Add: state.emit(" + ")
        case ast.Operator.Sub: state.emit(" - ")
        case ast.Operator.Mult: state.emit(" * ")
        case ast.Operator.Div: state.emit(" / ")
        case _: state.emit(" + ")
    generate_expr(state, deref(b.right))

def emit_bool_op(state: CodegenState, b: ast.ExprBoolOp):
    op_str_b = " && "
    match b.op:
        case ast.BoolOp.Or: op_str_b = " || "
        case _: pass
    idx_b: usize = 0
    for v in b.values.clone():
        if idx_b > 0: state.emit(op_str_b.clone())
        state.emit("(")
        generate_expr(state, v)
        state.emit(")")
        idx_b = idx_b + 1

def emit_unary_op(state: CodegenState, u: ast.ExprUnaryOp):
    match u.op:
        case ast.UnaryOp.Not: state.emit("!")
        case ast.UnaryOp.Invert: state.emit("!")
        case ast.UnaryOp.UAdd: state.emit("+")
        case ast.UnaryOp.USub: state.emit("-")
    generate_expr(state, deref(u.operand))

def emit_expr_if(state: CodegenState, i: ast.ExprIf):
    state.emit("if ")
    generate_expr(state, deref(i.test))
    state.emit(" { ")
    generate_expr(state, deref(i.body))
    state.emit(" } else { ")
    generate_expr(state, deref(i.orelse))
    state.emit(" }")

def emit_compare(state: CodegenState, c: ast.ExprCompare):
    generate_expr(state, deref(c.left))
    idx_c: usize = 0
    while idx_c < c.ops.len():
        op = c.ops[idx_c]
        state.emit(" ")
        match op:
            case ast.CmpOp.Eq: state.emit("==")
            case ast.CmpOp.NotEq: state.emit("!=")
            case ast.CmpOp.Lt: state.emit("<")
            case ast.CmpOp.LtE: state.emit("<=")
            case ast.CmpOp.Gt: state.emit(">")
            case ast.CmpOp.GtE: state.emit(">=")
            case _: state.emit("?")
        state.emit(" ")
        generate_expr(state, ast.Expr.clone(as_ref(c.comparators[idx_c])))
        idx_c = idx_c + 1

def emit_expr_tuple(state: CodegenState, t: ast.ExprTuple):
    state.emit("(")
    idx_t: usize = 0
    for e in t.elts:
        if idx_t > 0: state.emit(", ")
        generate_expr(state, e)
        idx_t = idx_t + 1
    state.emit(")")

def emit_attribute(state: CodegenState, a: ast.ExprAttribute):
    target_attr = deref(a.value)
    is_static_attr = False
    match state.get_root_name(ast.Expr.clone(as_ref(target_attr))):
        case Some(root_name):
            if state.is_type_or_mod(root_name.clone()):
                is_static_attr = True
            else:
                match state.symbols.lookup(root_name):
                    case Some(s):
                        if s.is_class or s.is_extern:
                            is_static_attr = True
                    case None: pass
        case None: pass
    if a.attr.as_str().to_string() == "new": is_static_attr = True
    
    match as_ref(target_attr):
        case ast.Expr.Subscript(s):
            if is_static_attr:
                full_expr = ast.Expr.clone(as_ref(target_attr))
                base_type = state.type_to_string(full_expr)
                if base_type.contains(as_ref("<")):
                    base_type = base_type.replace(as_ref("<"), as_ref("::<"))
                state.emit(base_type)
            else:
                emit_lvalue_target(state, ast.Expr.clone(as_ref(target_attr)))
        case _:
            if is_static_attr:
                emit_pattern_path(state, ast.Expr.clone(as_ref(target_attr)))
            else:
                emit_lvalue_target(state, ast.Expr.clone(as_ref(target_attr)))
    if is_static_attr: state.emit("::")
    else: state.emit(".")
    state.emit(a.attr.as_str().to_string())

def emit_subscript(state: CodegenState, s: ast.ExprSubscript):
    sub_is_map = False
    sub_is_list = False
    is_neg_s = False
    target_type_s = state.infer_expr_type(ast.Expr.clone(as_ref(s.value)))
    is_tuple_target = state.is_tuple_expr(ast.Expr.clone(as_ref(s.value)))
    tuple_via_symbol = False
    match as_ref(deref(s.value)):
        case ast.Expr.Name(n):
            match state.symbols.lookup(n.id.as_str().to_string()):
                case Some(sym):
                    if sym.type_name.contains(as_ref("(")) and sym.type_name.contains(as_ref(")")):
                        tuple_via_symbol = True
                case None: pass
        case _: pass
    tuple_via_registry = False
    match as_ref(deref(s.value)):
        case ast.Expr.Name(n):
            match state.tuple_vars.get(n.id.as_str().to_string()):
                case Some(_):
                    tuple_via_registry = True
                case None: pass
        case ast.Expr.Subscript(inner):
            match as_ref(deref(inner.value)):
                case ast.Expr.Name(n):
                    match state.tuple_vars.get(n.id.as_str().to_string()):
                        case Some(_):
                            tuple_via_registry = True
                        case None: pass
                case _: pass
        case _: pass

    if tuple_via_registry or tuple_via_symbol or is_tuple_target or target_type_s == "Tuple" or target_type_s.starts_with(as_ref("Tuple")) or target_type_s.starts_with(as_ref("(")):
        generate_expr(state, deref(s.value))
        state.emit(".")
        match deref(s.slice):
            case ast.Expr.NumberLiteral(n):
                match n.value:
                    case ast.Number.Int(i):
                        state.emit(i.to_string())
                    case _: state.emit("0")
            case _: state.emit("0")
    else:
        sub_is_map = state.is_dict_like_expr(ast.Expr.clone(as_ref(deref(s.value))))
        sub_is_list = state.is_list_like_expr(ast.Expr.clone(as_ref(deref(s.value))))
        is_neg_s = False
        sl_s = deref(s.slice)
        match sl_s.clone():
            case ast.Expr.UnaryOp(u):
                match u.op:
                    case ast.UnaryOp.USub: is_neg_s = True
                    case _: pass
            case _: pass

        if is_neg_s:
            match sl_s:
                case ast.Expr.UnaryOp(u):
                    generate_expr(state, ast.Expr.clone(as_ref(deref(s.value))))
                    if sub_is_list:
                        state.emit("[")
                        generate_expr(state, ast.Expr.clone(as_ref(deref(s.value))))
                        state.emit(".len() - ")
                        generate_expr(state, deref(u.operand))
                        state.emit("].clone()")
                    else:
                        state.emit("[")
                        generate_expr(state, ast.Expr.clone(as_ref(deref(s.value))))
                        state.emit(".len() - ")
                        generate_expr(state, deref(u.operand))
                        state.emit("]")
                case _: pass
        else:
            generate_expr(state, deref(s.value))
            sub_slice_is_string = False
            match sl_s:
                case ast.Expr.StringLiteral(_): sub_slice_is_string = True
                case _: pass
            if sub_is_map or sub_slice_is_string:
                state.emit("[&")
                generate_expr(state, sl_s)
                state.emit("].clone()")
            elif sub_is_list:
                state.emit("[")
                old_cn = state.clone_names
                state.clone_names = True
                generate_expr(state, sl_s)
                state.clone_names = old_cn
                state.emit("].clone()")
            else:
                state.emit("[")
                old_cn_2 = state.clone_names
                state.clone_names = True
                generate_expr(state, sl_s)
                state.clone_names = old_cn_2
                state.emit("]")

def emit_lambda(state: CodegenState, l: ast.ExprLambda):
    state.emit("(|")
    match l.parameters:
        case Some(p):
            idx_lam = 0
            for arg_def in p.args.clone():
                if idx_lam > 0: state.emit(", ")
                state.emit(arg_def.parameter.name.as_str().to_string())
                idx_lam = idx_lam + 1
        case None: pass
    state.emit("| ")
    generate_expr_no_clone(state, deref(l.body))
    state.emit(")")

def emit_fstring(state: CodegenState, f: ast.ExprFString):
    state.emit("format!(\"")
    f_args: List[ast.Expr] = []
    for part in f.value:
        match part:
            case ast.FStringPart.Literal(lit):
                state.emit(lit.value.to_string())
            case ast.FStringPart.FString(fs):
                for element in fs.elements:
                    match element:
                        case ast.InterpolatedStringElement.Literal(l):
                            state.emit(l.value.to_string())
                        case ast.InterpolatedStringElement.Interpolation(i):
                            state.emit("{}")
                            f_args.push(ast.Expr.clone(as_ref(deref(i.expression))))
    state.emit("\"")
    for arg in f_args:
        state.emit(", ")
        generate_expr(state, arg)
    state.emit(")")

def emit_dict(state: CodegenState, d: ast.ExprDict):
    state.emit("std::rc::Rc::new(std::collections::HashMap::from([")
    idx_dict = 0
    for item in d.items:
        if idx_dict > 0: state.emit(", ")
        key_val = as_ref(item).key
        val_val = as_ref(deref(as_ref(item).value))
        match key_val:
            case Some(k):
                state.emit("(")
                generate_expr(state, ast.Expr.clone(as_ref(k)))
                state.emit(", ")
                generate_expr(state, ast.Expr.clone(as_ref(val_val)))
                state.emit(")")
            case None:
                state.emit("/* **kwargs */")
        idx_dict = idx_dict + 1
    state.emit("]))")
