import ast
import types
from compiler.extern_defs import RustString, q_push, escape_rust_string, vec_to_list, deref, as_ref
from compiler.usage_analyzer import UsageAnalyzer
from compiler.codegen.state import CodegenState
import compiler.codegen.expr as expr_gen
import compiler.codegen.pattern as pattern_gen

def generate_stmt(state: CodegenState, stmt: ast.Stmt):
    match stmt:
        case ast.Stmt.FunctionDef(f): emit_function_def(state, f)
        case ast.Stmt.Expr(e): emit_stmt_expr(state, e)
        case ast.Stmt.Return(r): emit_return(state, r)
        case ast.Stmt.Try(t): emit_try(state, t)
        case ast.Stmt.Assign(a): emit_assign(state, a)
        case ast.Stmt.AnnAssign(a): emit_ann_assign(state, a)
        case ast.Stmt.For(f): emit_for(state, f)
        case ast.Stmt.If(i): emit_if(state, i)
        case ast.Stmt.While(w): emit_while(state, w)
        case ast.Stmt.ClassDef(c): emit_class_def(state, c)
        case ast.Stmt.Match(m): emit_match(state, m)
        case ast.Stmt.Import(i): emit_import(state, i)
        case ast.Stmt.ImportFrom(i): emit_import_from(state, i)
        case ast.Stmt.Assert(a): emit_assert(state, a)
        case _: state.emit("// Unimplemented stmt\n")

def emit_assert(state: CodegenState, a: ast.StmtAssert):
    state.emit("assert!(")
    expr_gen.generate_expr(state, deref(a.test))
    match a.msg:
        case Some(m):
            state.emit(", \"{:?}\", ")
            expr_gen.generate_expr(state, deref(m))
        case None: pass
    state.emit(");\n")

def emit_function_def(state: CodegenState, f: ast.StmtFunctionDef):
    is_extern = False
    extern_path = ""
    for dec in f.decorator_list.clone():
        match as_ref(dec.expression):
            case ast.Expr.Name(n):
                if n.id.as_str().to_string() == "extern":
                    is_extern = True
            case ast.Expr.Call(call):
                match as_ref(deref(call.func)):
                    case ast.Expr.Name(func_node):
                        if func_node.id.as_str().to_string() == "extern":
                            is_extern = True
                            for kw in call.arguments.keywords.clone():
                                match as_ref(kw.arg):
                                    case Some(ident):
                                        arg_name = ident.as_str().to_string()
                                        if arg_name == "path":
                                            match as_ref(kw.value):
                                                case ast.Expr.StringLiteral(s):
                                                    extern_path = s.value.to_string()
                                                case _: pass
                                        elif arg_name == "no_generic":
                                            pass
                                    case _: pass
                    case _: pass
            case _: pass
    
    func_name = f.name.as_str().to_string()
    state.symbols.insert(func_name.clone(), types.Symbol.func(func_name.clone(), is_extern))

    if is_extern:
        if extern_path != "":
            state.emit("pub use ")
            state.emit(extern_path)
            state.emit(" as ")
            state.emit(func_name)
            state.emit(";\n")
        else:
            state.emit("// Extern function ")
            state.emit(func_name)
            state.emit("\n")
        return

    analyzer = UsageAnalyzer.new()
    analyzer.analyze_body(vec_to_list(f.body.clone()))
    state.usage_ledger = analyzer.ledger
    state.current_stmt_idx = 0

    state.emit("pub fn ")
    state.emit(func_name)
    state.emit("(")
    state.symbols.enter_scope()
    state.enter_var_scope()
    first_arg: bool = True
    for param_def in f.parameters.args:
        if not first_arg:
            state.emit(", ")
        first_arg = False

        param = param_def.parameter
        if param.name.as_str().to_string() == "self":
            state.emit("&mut self")
        else:
            state.emit(param.name.as_str().to_string())
            state.emit(": ")
            if param.annotation.is_some():
                ann = param.annotation.clone().unwrap()
                type_name = state.type_to_string(deref(ann.clone()))
                state.emit(type_name.clone())
                state.symbols.insert(param.name.as_str().to_string(), types.Symbol.var(param.name.as_str().to_string(), type_name))
                state.mark_var_defined(param.name.as_str().to_string())
            else:
                state.emit("Any")
                pass
    state.emit(")")
    if f.returns.is_some():
        ret = f.returns.clone().unwrap()
        ret_type = state.type_to_string(deref(ret.clone()))
        state.emit(" -> ")
        state.emit(ret_type)
    state.emit(" {\n")

    for s in f.body:
        generate_stmt(state, s)
        state.current_stmt_idx = state.current_stmt_idx + 1
    state.exit_var_scope()
    state.symbols.exit_scope()
    state.emit("}\n")

def emit_stmt_expr(state: CodegenState, e: ast.StmtExpr):
    is_doc = False
    match as_ref(deref(e.value)):
        case ast.Expr.StringLiteral(s):
            is_doc = True
            state.emit("#![doc = \"")
            state.emit(escape_rust_string(s.value.to_string()))
            state.emit("\"]\n")
        case _: pass

    if not is_doc:
        expr_gen.generate_expr(state, deref(e.value))
        state.emit(";\n")

def emit_return(state: CodegenState, r: ast.StmtReturn):
    state.emit("return ")
    match r.value:
        case Some(v):
            expr_gen.generate_expr(state, deref(v))
        case None: pass
    state.emit(";\n")

def emit_try(state: CodegenState, t: ast.StmtTry):
    state.emit("let _quiche_try_result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n")
    state.enter_var_scope()
    for s in t.body:
        generate_stmt(state, s)
    state.exit_var_scope()
    state.emit("}));\n")

    state.emit("if let Err(_quiche_err) = _quiche_try_result {\n")
    for handler in t.handlers:
        match handler:
            case ast.ExceptHandler.ExceptHandler(inner):
                match inner.name:
                    case Some(name):
                        state.emit("let ")
                        state.emit(name.as_str().to_string())
                        state.emit(" = _quiche_err.downcast_ref::<String>().map(|s| s.clone()).or_else(|| _quiche_err.downcast_ref::<&str>().map(|s| s.to_string())).unwrap_or_else(|| \"Unknown Error\".to_string());\n")
                    case None: pass
                state.enter_var_scope()
                for stmt in inner.body:
                    generate_stmt(state, stmt)
                state.exit_var_scope()
            case _: pass
    state.emit("}\n")

def emit_assign(state: CodegenState, a: ast.StmtAssign):
    is_subscript = False
    subscript_is_map = False
    match as_ref(a.targets[0]):
        case ast.Expr.Name(n):
            name_assign = n.id.as_str().to_string()
            is_existing = state.is_var_defined_in_scopes(name_assign.clone())
            if not is_existing:
                if state.expr_contains_name(ast.Expr.clone(as_ref(deref(a.value))), name_assign.clone()):
                    is_existing = True
            if not is_existing:
                state.emit("let mut ")
            state.emit(name_assign.clone())
            state.emit(" = ")
            assign_val_type = state.infer_expr_type(ast.Expr.clone(as_ref(deref(a.value))))
            if not is_existing:
                state.symbols.insert(name_assign.clone(), types.Symbol.var(name_assign.clone(), assign_val_type))
                state.define_var(name_assign.clone())
                state.mark_var_defined(name_assign.clone())
            match as_ref(deref(a.value)):
                case ast.Expr.Tuple(_):
                    state.tuple_vars.insert(name_assign.clone(), True)
                case _: pass
        case ast.Expr.Attribute(at):
            expr_gen.emit_attribute_target(state, at.clone())
            state.emit(" = ")
        case ast.Expr.Subscript(s):
            is_subscript = True
            is_map = state.is_dict_like_expr(ast.Expr.clone(as_ref(deref(s.value))))
            assign_slice_is_string = False
            match deref(s.slice.clone()):
                case ast.Expr.StringLiteral(_): assign_slice_is_string = True
                case _: pass
            if assign_slice_is_string:
                is_map = True
            subscript_is_map = is_map
            if is_map:
                state.emit("std::rc::Rc::make_mut(&mut ")
                expr_gen.emit_lvalue_target(state, deref(s.value.clone()))
                state.emit(").insert(")
                expr_gen.generate_expr(state, deref(s.slice.clone()))
                state.emit(", ")
            else:
                state.emit("std::rc::Rc::make_mut(&mut ")
                expr_gen.emit_lvalue_target(state, deref(s.value.clone()))
                state.emit(")[")
                expr_gen.generate_expr(state, deref(s.slice.clone()))
                state.emit("] = ")
        case _: pass
    expr_gen.generate_expr(state, deref(a.value))
    if is_subscript and subscript_is_map:
        state.emit(")")
    state.emit(";\n")

def emit_ann_assign(state: CodegenState, a: ast.StmtAnnAssign):
    match as_ref(deref(a.target)):
        case ast.Expr.Name(n):
            ann_type_name = state.type_to_string(ast.Expr.clone(as_ref(deref(a.annotation.clone()))))
            is_tuple_ann = ann_type_name.starts_with(as_ref("(")) or ann_type_name.starts_with(as_ref("Tuple"))
            state.emit("let mut ")
            state.emit(n.id.as_str().to_string())
            state.emit(": ")
            state.emit(ann_type_name.clone())
            state.emit(" = ")
            state.symbols.insert(n.id.as_str().to_string(), types.Symbol.var(n.id.as_str().to_string(), ann_type_name.clone()))
            state.mark_var_defined(n.id.as_str().to_string())
            if is_tuple_ann:
                state.tuple_vars.insert(n.id.as_str().to_string(), True)
        case _: pass
    match a.value:
        case Some(v):
            expr_gen.generate_expr(state, deref(v))
        case None:
            state.emit("Default::default()")
    state.emit(";\n")

def emit_for(state: CodegenState, f: ast.StmtFor):
    prev_clone = state.clone_names
    state.clone_names = True
    iter_expr_f = ast.Expr.clone(as_ref(deref(f.iter)))
    is_map = state.is_dict_like_expr(iter_expr_f.clone())
    is_list = state.is_list_like_expr(iter_expr_f.clone())
    is_attr = False
    match as_ref(deref(f.iter)):
        case ast.Expr.Attribute(_): is_attr = True
        case ast.Expr.Subscript(_): is_attr = True
        case _: pass
    if is_map:
        state.emit("for __q in (")
        match as_ref(deref(f.iter)):
            case ast.Expr.Name(n):
                state.emit(n.id.as_str().to_string())
                state.emit(".clone()")
            case _:
                expr_gen.generate_expr(state, deref(f.iter))
        state.emit(").keys() {\n")
    elif is_list or is_attr:
        state.emit("for __q in (")
        match as_ref(deref(f.iter)):
            case ast.Expr.Name(n):
                state.emit(n.id.as_str().to_string())
                state.emit(".clone()")
            case _:
                expr_gen.generate_expr(state, deref(f.iter))
        state.emit(").iter() {\n")
    else:
        state.emit("for __q in quiche_runtime::QuicheIterable::quiche_iter(")
        match as_ref(deref(f.iter)):
            case ast.Expr.Name(n):
                state.emit(n.id.as_str().to_string())
                state.emit(".clone()")
            case _:
                expr_gen.generate_expr(state, deref(f.iter))
        state.emit(") {\n")
    state.emit("let ")
    match as_ref(deref(f.target)):
        case ast.Expr.Name(n):
            state.emit(n.id.as_str().to_string())
        case _:
            state.emit("_")
    state.emit(" = quiche_runtime::check!(__q);\n")
    state.enter_var_scope()
    state.clone_names = prev_clone
    for s in f.body:
        generate_stmt(state, s)
    state.exit_var_scope()
    state.emit("}\n")

def emit_if(state: CodegenState, i: ast.StmtIf):
    state.emit("if ")
    expr_gen.generate_expr(state, deref(i.test))
    state.emit(" {\n")
    state.enter_var_scope()
    for s in i.body:
        generate_stmt(state, s)
    state.exit_var_scope()
    state.emit("}")
    for clause in i.elif_else_clauses:
        match clause.test:
            case Some(t):
                state.emit(" else if ")
                expr_gen.generate_expr(state, t)
                state.emit(" {\n")
                state.enter_var_scope()
                for s in clause.body:
                    generate_stmt(state, s)
                state.exit_var_scope()
                state.emit("}")
            case None:
                state.emit(" else {\n")
                state.enter_var_scope()
                for s in clause.body:
                    generate_stmt(state, s)
                state.exit_var_scope()
                state.emit("}")
    state.emit("\n")

def emit_while(state: CodegenState, w: ast.StmtWhile):
    state.emit("while ")
    expr_gen.generate_expr(state, deref(w.test))
    state.emit(" {\n")
    state.enter_var_scope()
    for s in w.body:
        generate_stmt(state, s)
    state.exit_var_scope()
    state.emit("}\n")

def emit_class_def(state: CodegenState, c: ast.StmtClassDef):
    is_enum = False
    is_extern = False
    extern_path = ""
    no_generic = False
    for dec in c.decorator_list.clone():
        match as_ref(dec.expression):
            case ast.Expr.Name(n):
                if n.id.as_str().to_string() == "enum":
                    is_enum = True
                if n.id.as_str().to_string() == "extern":
                    is_extern = True
            case ast.Expr.Call(call):
                match as_ref(deref(call.func)):
                    case ast.Expr.Name(func_node):
                        if func_node.id.as_str().to_string() == "extern":
                            is_extern = True
                            for kw in call.arguments.keywords.clone():
                                match as_ref(kw.arg):
                                    case Some(ident):
                                        arg_name = ident.as_str().to_string()
                                        if arg_name == "path":
                                            match as_ref(kw.value):
                                                case ast.Expr.StringLiteral(s):
                                                    extern_path = s.value.to_string()
                                                case _: pass
                                        elif arg_name == "no_generic":
                                            match as_ref(kw.value):
                                                case ast.Expr.BooleanLiteral(b):
                                                    no_generic = b.value
                                                case _: pass
                                    case _: pass
                    case _: pass
            case _: pass

    class_name = c.name.as_str().to_string()
    state.symbols.insert(class_name.clone(), types.Symbol.clazz(class_name.clone(), is_extern))

    if is_extern:
        if extern_path != "":
            state.emit("pub type ")
            state.emit(c.name.as_str().to_string())
            if no_generic:
                state.emit(" = ")
                state.emit(extern_path)
                state.emit(";\n")
            else:
                state.emit("<T> = ")
                state.emit(extern_path)
                state.emit("<T>;\n")
        else:
            state.emit("// Extern class ")
            state.emit(c.name.as_str().to_string())
            state.emit("\n")
        return

    if is_enum:
        state.emit("#[derive(Clone, Debug)]\n")
        state.emit("pub enum ")
    else:
        state.emit("#[derive(Clone, Debug, Default)]\n")
        state.emit("pub struct ")
    state.emit(c.name.as_str().to_string())
    state.emit(" {\n")

    if is_enum:
        for s in c.body.clone():
            match s:
                case ast.Stmt.AnnAssign(a):
                    match as_ref(deref(a.target)):
                        case ast.Expr.Name(n):
                            state.emit(n.id.as_str().to_string())
                            state.emit("(")
                            match deref(a.annotation):
                                case ast.Expr.List(l):
                                    idx_enum: usize = 0
                                    for t in l.elts.clone():
                                        if idx_enum > 0: state.emit(", ")
                                        t_str_enum = state.type_to_string(t)
                                        state.emit(t_str_enum)
                                        idx_enum = idx_enum + 1
                                case _: pass
                            state.emit("),\n")
                        case _: pass
                case _: pass
    else:
        for s in c.body.clone():
            match s:
                case ast.Stmt.AnnAssign(a):
                    match as_ref(deref(a.target)):
                        case ast.Expr.Name(n):
                            state.emit("pub ")
                            state.emit(n.id.as_str().to_string())
                            state.emit(": ")
                            ann_str_f = state.type_to_string(ast.Expr.clone(as_ref(deref(a.annotation.clone()))))
                            state.register_class_field(class_name.clone(), n.id.as_str().to_string(), ann_str_f.clone())
                            state.emit(ann_str_f)
                            state.emit(",\n")
                        case _: pass
                case _: pass
    state.emit("}\n")

    if not is_enum:
        state.emit("impl ")
        state.emit(c.name.as_str().to_string())
        state.emit(" {\n")
        state.set_current_class(class_name.clone())
        for s in c.body:
            match s:
                case ast.Stmt.FunctionDef(_):
                    generate_stmt(state, s)
                case _: pass
        state.clear_current_class()
        state.emit("}\n")

def emit_match(state: CodegenState, m: ast.StmtMatch):
    state.emit("match ")
    expr_gen.generate_expr(state, deref(m.subject))
    state.emit(" {\n")
    for case_ in m.cases:
        pattern_gen.generate_pattern(state, ast.Pattern.clone(as_ref(case_.pattern)))
        match case_.guard:
            case Some(g):
                state.emit(" if ")
                expr_gen.generate_expr(state, deref(g.clone()))
            case None: pass
        state.emit(" => {\n")
        state.enter_var_scope()
        for s in case_.body:
            generate_stmt(state, s)
        state.exit_var_scope()
        state.emit("}\n")
    state.emit("}\n")

def emit_import(state: CodegenState, i: ast.StmtImport):
    dot_imp = "."
    sep_imp = "::"
    for alias in i.names:
        is_root_module = state.current_module_path == "" or state.current_module_path == "main" or state.current_module_path == "lib"
        alias_name_raw = alias.name.as_str().to_string()
        rust_p = "rust."
        std_p = "std."
        alias_name = alias.name.as_str().to_string()
        match alias.asname.clone():
            case Some(a): alias_name = a.as_str().to_string()
            case None: pass

        rust_path_opt = None
        match state.import_paths.get(alias_name.clone()):
            case Some(p): rust_path_opt = Some(p.clone())
            case None: pass

        match rust_path_opt:
            case Some(rust_path):
                if is_root_module and rust_path.starts_with(as_ref("crate::")):
                    state.register_import_symbol(alias_name.clone())
                    continue
                state.emit("use ")
                state.emit(rust_path)
                match alias.asname.clone():
                    case Some(_):
                        state.emit(" as ")
                        state.emit(alias_name.clone())
                    case None: pass
                state.emit(";\n")
            case None:
                if not alias_name_raw.starts_with(rust_p.as_str()) and not alias_name_raw.starts_with(std_p.as_str()):
                    if is_root_module and alias.asname.is_none() and not alias_name_raw.contains(as_ref(".")):
                        state.register_import_symbol(alias_name.clone())
                        continue
                    state.emit("use crate::")
                else:
                    state.emit("use ")
                dot_v = "."
                sep_v = "::"
                state.emit(alias_name_raw.replace(dot_v.as_str(), sep_v.as_str()))
                state.emit(";\n")
        
        state.register_import_symbol(alias_name.clone())

def emit_import_from(state: CodegenState, i: ast.StmtImportFrom):
    mod_sep = "."
    mod_col = "::"
    for alias in i.names:
        match i.module.clone():
            case Some(m):
                if m.as_str().to_string() == "lib.test": return
            case None: pass
        alias_name = alias.name.as_str().to_string()
        match alias.asname.clone():
            case Some(a): alias_name = a.as_str().to_string()
            case None: pass

        rust_path_opt = None
        match state.import_paths.get(alias_name.clone()):
            case Some(p): rust_path_opt = Some(p.clone())
            case None: pass
        
        match rust_path_opt:
            case Some(rust_path):
                state.emit("use ")
                state.emit(rust_path)
                match alias.asname.as_ref():
                    case Some(_):
                        state.emit(" as ")
                        state.emit(alias_name.clone())
                    case None: pass
                state.emit(";\n")
            case None:
                state.emit("use ")
                match i.module.clone():
                    case Some(m):
                        m_str = m.as_str().to_string()
                        if m_str == "lib.test": return
                        r_p = "rust."
                        s_p = "std."
                        if not m_str.starts_with(r_p.as_str()) and not m_str.starts_with(s_p.as_str()):
                            if i.level == 0: state.emit("crate::")
                    case None: pass
                l_lvl = i.level
                k_lvl: u32 = 0
                while k_lvl < l_lvl:
                    state.emit("super::")
                    k_lvl = k_lvl + 1
                match i.module.clone():
                    case Some(m):
                        mod_name = m.as_str().to_string()
                        if mod_name == "rust":
                            mod_name = ""
                        elif mod_name.starts_with(as_ref("rust.")):
                            mod_name = mod_name.replace(as_ref("rust."), as_ref(""))
                        if mod_name != "":
                            state.emit(mod_name.replace(mod_sep.as_str(), mod_col.as_str()))
                            state.emit("::")
                    case None: pass
                state.emit(alias.name.as_str().to_string().replace(mod_sep.as_str(), mod_col.as_str()))
                match alias.asname.as_ref():
                    case Some(a):
                        state.emit(" as ")
                        state.emit(a.as_str().to_string())
                    case None: pass
                state.emit(";\n")
        state.register_import_symbol(alias_name.clone())
