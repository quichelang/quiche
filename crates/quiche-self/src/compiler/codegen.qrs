import ast
import types

@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def len(self) -> usize: pass
    def as_str(self) -> StrRef: pass

@extern(path="crate::quiche::push_str_wrapper")
def q_push(s: RustString, val: String) -> RustString: pass

@extern(path="crate::quiche::escape_rust_string")
def escape_rust_string(s: String) -> String: pass

class UsageAnalyzer:
    ledger: Dict[String, types.UsageInfo]
    current_idx: i32
    loop_depth: i32

    def new() -> UsageAnalyzer:
        return UsageAnalyzer(ledger=Dict[String, types.UsageInfo].new(), current_idx=0, loop_depth=0)

    def analyze_body(self, body: List[ast.Stmt]):
        self.ledger = Dict[String, types.UsageInfo].new()
        self.current_idx = 0
        self.loop_depth = 0
        for stmt in body:
            self.analyze_stmt(stmt)
            self.current_idx = self.current_idx + 1

    def analyze_stmt(self, stmt: ast.Stmt):
        match stmt:
            case ast.Stmt.Assign(a):
                match as_ref(a.targets[0]):
                    case ast.Expr.Name(n):
                        self.record_usage(n.id.as_str().to_string(), True)
                    case _: pass
                self.analyze_expr(deref(a.value))
            case ast.Stmt.Expr(e):
                self.analyze_expr(deref(e.value))
            case ast.Stmt.If(i):
                self.analyze_expr(deref(i.test))
                for s in i.body: self.analyze_stmt(s)
                for clause in i.elif_else_clauses:
                    match clause.test:
                        case Some(t): self.analyze_expr(t)
                        case None: pass
                    for s in clause.body: self.analyze_stmt(s)
                for s in i.orelse: self.analyze_stmt(s)
            
            case ast.Stmt.Return(r):
                match r.value:
                    case Some(v): self.analyze_expr(deref(v))
                    case None: pass

            case ast.Stmt.For(f):
                self.analyze_expr(deref(f.iter))
                self.loop_depth = self.loop_depth + 1
                for s in f.body: self.analyze_stmt(s)
                self.loop_depth = self.loop_depth - 1
                for s in f.orelse: self.analyze_stmt(s)

            case ast.Stmt.While(w):
                self.analyze_expr(deref(w.test))
                self.loop_depth = self.loop_depth + 1
                for s in w.body: self.analyze_stmt(s)
                self.loop_depth = self.loop_depth - 1
                for s in w.orelse: self.analyze_stmt(s)

            case ast.Stmt.Match(m):
                self.analyze_expr(deref(m.subject))
                for case_ in m.cases:
                    match case_.guard:
                        case Some(g): self.analyze_expr(deref(g))
                        case None: pass
                    for s in case_.body: self.analyze_stmt(s)

            case ast.Stmt.AnnAssign(a):
                match as_ref(deref(a.target)):
                    case ast.Expr.Name(n):
                         self.record_usage(n.id.as_str().to_string(), True)
                    case _: pass
                match a.value:
                    case Some(v): self.analyze_expr(deref(v))
                    case None: pass

            case ast.Stmt.Assert(a):
                self.analyze_expr(deref(a.test))
                match a.msg:
                    case Some(m): self.analyze_expr(deref(m))
                    case None: pass

            case _: pass

    def analyze_expr(self, expr: ast.Expr):
        match expr:
            case ast.Expr.Name(n):
                self.record_usage(n.id.as_str().to_string(), False)
            case ast.Expr.BinOp(b):
                self.analyze_expr(deref(b.left))
                self.analyze_expr(deref(b.right))
            case ast.Expr.UnaryOp(u):
                self.analyze_expr(deref(u.operand))
            case ast.Expr.BoolOp(b):
                for v in b.values: self.analyze_expr(v)
            case ast.Expr.Compare(c):
                self.analyze_expr(deref(c.left))
                for v in c.comparators: self.analyze_expr(v)
            case ast.Expr.Call(c):
                self.analyze_expr(deref(c.func))
                for arg in c.arguments.args:
                    self.analyze_expr(arg)
                for kw in c.arguments.keywords:
                    self.analyze_expr(deref(kw.value))
            case ast.Expr.Attribute(a):
                self.analyze_expr(deref(a.value))
            case ast.Expr.Subscript(s):
                self.analyze_expr(deref(s.value))
                self.analyze_expr(deref(s.slice))
            case ast.Expr.List(l):
                for e in l.elts: self.analyze_expr(e)
            case ast.Expr.Tuple(t):
                for e in t.elts: self.analyze_expr(e)
            case ast.Expr.If(i):
                 self.analyze_expr(deref(i.test))
                 self.analyze_expr(deref(i.body))
                 self.analyze_expr(deref(i.orelse))
            case ast.Expr.Dict(d):
                pass
            case ast.Expr.Lambda(l):
                self.analyze_expr(deref(l.body))
            case _: pass

    def record_usage(self, name: String, is_mutation: bool):
        idx = self.current_idx
        if self.loop_depth > 0:
            idx = idx + 1
        
        match self.ledger.get(name.clone()):
            case Some(info):
                new_mut = is_mutation
                if info.is_mutated: new_mut = True
                self.ledger.insert(name.clone(), types.UsageInfo.new(idx, new_mut))
            case None:
                self.ledger.insert(name.clone(), types.UsageInfo.new(idx, is_mutation))

class Codegen:
    output: RustString
    symbols: types.SymbolTable
    tuple_vars: Dict[String, bool]
    defined_vars: List[Dict[String, bool]]
    import_paths: Dict[String, String]
    import_kinds: Dict[String, String]
    clone_names: bool
    current_module_path: String
    class_fields: Dict[String, Dict[String, String]]
    current_class: String
    usage_ledger: Dict[String, types.UsageInfo]
    current_stmt_idx: i32

    def __init__(self):
        self.output = RustString.new()
        self.symbols = types.SymbolTable.new()
        self.tuple_vars = Dict[String, bool].new()
        self.defined_vars = [Dict[String, bool].new()]
        self.import_paths = Dict[String, String].new()
        self.import_kinds = Dict[String, String].new()
        self.clone_names = True
        self.current_module_path = ""
        self.class_fields = Dict[String, Dict[String, String]].new()
        self.current_class = ""
        self.usage_ledger = Dict[String, types.UsageInfo].new()
        self.current_stmt_idx = 0

    def new() -> Codegen:
        return Codegen(output=RustString.new(), symbols=types.SymbolTable.new(), tuple_vars=Dict[String, bool].new(), defined_vars=[Dict[String, bool].new()], import_paths=Dict[String, String].new(), import_kinds=Dict[String, String].new(), clone_names=True, current_module_path="", class_fields=Dict[String, Dict[String, String]].new(), current_class="", usage_ledger=Dict[String, types.UsageInfo].new(), current_stmt_idx=0)

    def new_with_imports(import_paths: Dict[String, String], import_kinds: Dict[String, String]) -> Codegen:
        return Codegen(output=RustString.new(), symbols=types.SymbolTable.new(), tuple_vars=Dict[String, bool].new(), defined_vars=[Dict[String, bool].new()], import_paths=import_paths, import_kinds=import_kinds, clone_names=True, current_module_path="", class_fields=Dict[String, Dict[String, String]].new(), current_class="", usage_ledger=Dict[String, types.UsageInfo].new(), current_stmt_idx=0)

    def new_with_imports_and_module(import_paths: Dict[String, String], import_kinds: Dict[String, String], current_module_path: String) -> Codegen:
        return Codegen(output=RustString.new(), symbols=types.SymbolTable.new(), tuple_vars=Dict[String, bool].new(), defined_vars=[Dict[String, bool].new()], import_paths=import_paths, import_kinds=import_kinds, clone_names=True, current_module_path=current_module_path, class_fields=Dict[String, Dict[String, String]].new(), current_class="", usage_ledger=Dict[String, types.UsageInfo].new(), current_stmt_idx=0)

    def generate_expr_no_clone(self, expr: ast.Expr):
        prev = self.clone_names
        self.clone_names = False
        self.generate_expr(expr)
        self.clone_names = prev

    def register_class_field(self, class_name: String, field_name: String, field_type: String):
        match self.class_fields.get(class_name.clone()):
            case Some(fields):
                fields.insert(field_name.clone(), field_type.clone())
            case None:
                fields = Dict[String, String].new()
                fields.insert(field_name.clone(), field_type.clone())
                self.class_fields.insert(class_name.clone(), fields)

    def set_current_class(self, class_name: String):
        self.current_class = class_name

    def clear_current_class(self):
        self.current_class = ""

    def get_self_field_type(self, field_name: String) -> String:
        if self.current_class == "": return ""
        match self.class_fields.get(self.current_class.clone()):
            case Some(fields):
                match fields.get(field_name.clone()):
                    case Some(t): return t
                    case None: return ""
            case None: return ""

    def is_list_like_expr(self, expr: ast.Expr) -> bool:
        match expr:
            case ast.Expr.List(_): return True
            case ast.Expr.Name(_):
                t = self.infer_expr_type(expr)
                return t.contains(as_ref("Vec")) or t.contains(as_ref("List"))
            case ast.Expr.Attribute(a):
                match as_ref(deref(a.value)):
                    case ast.Expr.Name(n):
                        if n.id.as_str().to_string() == "self":
                            t = self.get_self_field_type(a.attr.as_str().to_string())
                            return t.contains(as_ref("Vec")) or t.contains(as_ref("List"))
                        base_type = self.infer_expr_type(ast.Expr.Name(n))
                        match self.class_fields.get(base_type):
                            case Some(fields):
                                match fields.get(a.attr.as_str().to_string()):
                                    case Some(ft):
                                        return ft.contains(as_ref("Vec")) or ft.contains(as_ref("List"))
                                    case None: pass
                            case None: pass
                    case _: pass
                return False
            case _: return False

    def is_dict_like_expr(self, expr: ast.Expr) -> bool:
        match expr:
            case ast.Expr.Dict(_): return True
            case ast.Expr.Name(_):
                t = self.infer_expr_type(expr)
                return t.contains(as_ref("HashMap")) or t.contains(as_ref("Dict"))
            case ast.Expr.Attribute(a):
                match as_ref(deref(a.value)):
                    case ast.Expr.Name(n):
                        if n.id.as_str().to_string() == "self":
                            t = self.get_self_field_type(a.attr.as_str().to_string())
                            return t.contains(as_ref("HashMap")) or t.contains(as_ref("Dict"))
                        base_type = self.infer_expr_type(ast.Expr.Name(n))
                        match self.class_fields.get(base_type):
                            case Some(fields):
                                match fields.get(a.attr.as_str().to_string()):
                                    case Some(ft):
                                        return ft.contains(as_ref("HashMap")) or ft.contains(as_ref("Dict"))
                                    case None: pass
                            case None: pass
                    case _: pass
                return False
            case _: return False

    def register_import_symbol(self, name: String):
        match self.import_kinds.get(name.clone()):
            case Some(kind):
                if kind == "module":
                    self.symbols.insert(name.clone(), types.Symbol.module(name.clone()))
                elif kind == "type":
                    self.symbols.insert(name.clone(), types.Symbol.clazz(name.clone(), False))
                elif kind == "func":
                    self.symbols.insert(name.clone(), types.Symbol.func(name.clone(), False))
                else:
                    self.symbols.insert(name.clone(), types.Symbol.var(name.clone(), "inferred"))
            case None:
                self.symbols.insert(name.clone(), types.Symbol.module(name.clone()))

    def emit(self, s: String):
        self.output = q_push(self.output.clone(), s)

    def generate_stmt(self, stmt: ast.Stmt):
        match stmt:
            case ast.Stmt.FunctionDef(f):
                self.emit_function_def(f)
            case ast.Stmt.Expr(e):
                self.emit_stmt_expr(e)
            case ast.Stmt.Return(r):
                self.emit_return(r)
            case ast.Stmt.Try(t):
                self.emit_try(t)
            case ast.Stmt.Assign(a):
                self.emit_assign(a)
            case ast.Stmt.AnnAssign(a):
                self.emit_ann_assign(a)
            case ast.Stmt.For(f):
                self.emit_for(f)
            case ast.Stmt.If(i):
                self.emit_if(i)
            case ast.Stmt.While(w):
                self.emit_while(w)
            case ast.Stmt.ClassDef(c):
                self.emit_class_def(c)
            case ast.Stmt.Match(m):
                self.emit_match(m)
            case ast.Stmt.Import(i):
                self.emit_import(i)
            case ast.Stmt.ImportFrom(i):
                self.emit_import_from(i)
            case ast.Stmt.Assert(a):
                self.emit_assert(a)
            case _:
                self.emit("// Unimplemented stmt\n")

    def emit_assert(self, a: ast.StmtAssert):
        self.emit("assert!(")
        self.generate_expr(deref(a.test))
        match a.msg:
            case Some(m):
                self.emit(", \"{:?}\", ")
                self.generate_expr(deref(m))
            case None: pass
        self.emit(");\n")

    def emit_function_def(self, f: ast.StmtFunctionDef):
        # Check for @extern
        is_extern = False
        extern_path = ""
        for dec in f.decorator_list.clone():
            match as_ref(dec.expression):
                case ast.Expr.Name(n):
                    if n.id.as_str().to_string() == "extern":
                        is_extern = True
                case ast.Expr.Call(call):
                    match as_ref(deref(call.func)):
                        case ast.Expr.Name(func_node):
                            if func_node.id.as_str().to_string() == "extern":
                                is_extern = True
                                for kw in call.arguments.keywords.clone():
                                    match as_ref(kw.arg):
                                        case Some(ident):
                                            arg_name = ident.as_str().to_string()
                                            if arg_name == "path":
                                                match as_ref(kw.value):
                                                    case ast.Expr.StringLiteral(s):
                                                        extern_path = s.value.to_string()
                                                    case _: pass
                                            elif arg_name == "no_generic":
                                                pass
                                        case _: pass
                        case _: pass
                case _: pass
        
        # if f.decorator_list.len() > 0:
        #    self.emit_function_def_decorator(f)
        #    return

        func_name = f.name.as_str().to_string()
        self.symbols.insert(func_name.clone(), types.Symbol.func(func_name.clone(), is_extern))

        if is_extern:
            if extern_path != "":
                self.emit("pub use ")
                self.emit(extern_path)
                self.emit(" as ")
                self.emit(func_name)
                self.emit(";\n")
            else:
                self.emit("// Extern function ")
                self.emit(func_name)
                self.emit("\n")
            return

        # NEW: Analyze usage before emitting anything
        analyzer = UsageAnalyzer.new()
        analyzer.analyze_body(f.body.clone())
        self.usage_ledger = analyzer.ledger
        self.current_stmt_idx = 0

        self.emit("pub fn ")
        self.emit(func_name)
        self.emit("(")
        self.symbols.enter_scope()
        self.enter_var_scope()
        # Register keys and emit args
        first_arg: bool = True
        for param_def in f.parameters.args:
            if not first_arg:
                self.emit(", ")
            first_arg = False

            param = param_def.parameter
            if param.name.as_str().to_string() == "self":
                self.emit("&mut self")
            else:
                self.emit(param.name.as_str().to_string())
                self.emit(": ")
                if param.annotation.is_some():
                    ann = param.annotation.clone().unwrap()
                    type_name = self.type_to_string(deref(ann))
                    self.emit(type_name.clone())
                    self.symbols.insert(param.name.as_str().to_string(), types.Symbol.var(param.name.as_str().to_string(), type_name))
                    self.mark_var_defined(param.name.as_str().to_string())
                else:
                    self.emit("Any")
                    pass
        self.emit(")")
        if f.returns.is_some():
            ret = f.returns.clone().unwrap()
            ret_type = self.type_to_string(deref(ret))
            self.emit(" -> ")
            self.emit(ret_type)
        self.emit(" {\n")

        for s in f.body:
            self.generate_stmt(s)
            self.current_stmt_idx = self.current_stmt_idx + 1
        self.exit_var_scope()
        self.symbols.exit_scope()
        self.emit("}\n")

    def emit_stmt_expr(self, e: ast.StmtExpr):
        self.generate_expr(deref(e.value))
        self.emit(";\n")

    def emit_return(self, r: ast.StmtReturn):
        self.emit("return ")
        match r.value:
            case Some(v):
                self.generate_expr(deref(v))
            case None: pass
        self.emit(";\n")

    def emit_try(self, t: ast.StmtTry):
        self.emit("let _quiche_try_result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n")
        self.enter_var_scope()
        for s in t.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}));\n")

        self.emit("if let Err(_quiche_err) = _quiche_try_result {\n")
        for handler in t.handlers:
            match handler:
                case ast.ExceptHandler.ExceptHandler(inner):
                    match inner.name:
                        case Some(name):
                            self.emit("let ")
                            self.emit(name.as_str().to_string())
                            self.emit(" = _quiche_err.downcast_ref::<String>().map(|s| s.clone()).or_else(|| _quiche_err.downcast_ref::<&str>().map(|s| s.to_string())).unwrap_or_else(|| \"Unknown Error\".to_string());\n")
                        case None: pass
                    self.enter_var_scope()
                    for stmt in inner.body:
                        self.generate_stmt(stmt)
                    self.exit_var_scope()
                case _: pass
        self.emit("}\n")

    def emit_assign(self, a: ast.StmtAssign):
        # Simple single target assignment
        is_subscript = False
        subscript_is_map = False
        match as_ref(a.targets[0]):
            case ast.Expr.Name(n):
                name_assign = n.id.as_str().to_string()
                is_existing = self.is_var_defined_in_scopes(name_assign.clone())
                if not is_existing:
                    if self.expr_contains_name(ast.Expr.clone(as_ref(deref(a.value))), name_assign.clone()):
                        is_existing = True
                if not is_existing:
                    self.emit("let mut ")
                self.emit(name_assign.clone())
                self.emit(" = ")
                assign_val_type = self.infer_expr_type(ast.Expr.clone(as_ref(deref(a.value))))
                if not is_existing:
                    self.symbols.insert(name_assign.clone(), types.Symbol.var(name_assign.clone(), assign_val_type))
                    self.define_var(name_assign.clone())
                    self.mark_var_defined(name_assign.clone())
                match as_ref(deref(a.value)):
                    case ast.Expr.Tuple(_):
                        self.tuple_vars.insert(name_assign.clone(), True)
                    case _: pass
            case ast.Expr.Attribute(at):
                self.emit_attribute_target(at)
                self.emit(" = ")
            case ast.Expr.Subscript(s):
                is_subscript = True
                is_map = self.is_dict_like_expr(ast.Expr.clone(as_ref(deref(s.value))))
                subscript_is_map = is_map
                if is_map:
                    self.generate_expr(deref(s.value))
                    self.emit(".borrow_mut().insert(")
                    self.generate_expr(deref(s.slice))
                    self.emit(", ")
                else:
                    self.generate_expr(deref(s.value))
                    self.emit(".borrow_mut()[")
                    self.generate_expr(deref(s.slice))
                    self.emit("] = ")
            case _: pass
        self.generate_expr(deref(a.value))
        if is_subscript and subscript_is_map:
            self.emit(")")
        self.emit(";\n")

    def emit_ann_assign(self, a: ast.StmtAnnAssign):
        match as_ref(deref(a.target)):
            case ast.Expr.Name(n):
                ann_type_name = self.type_to_string(ast.Expr.clone(as_ref(deref(a.annotation))))
                is_tuple_ann = ann_type_name.starts_with(as_ref("(")) or ann_type_name.starts_with(as_ref("Tuple"))
                self.emit("let mut ")
                self.emit(n.id.as_str().to_string())
                self.emit(": ")
                self.emit(ann_type_name.clone())
                self.emit(" = ")
                self.symbols.insert(n.id.as_str().to_string(), types.Symbol.var(n.id.as_str().to_string(), ann_type_name.clone()))
                self.define_var(n.id.as_str().to_string())
                if is_tuple_ann:
                    self.tuple_vars.insert(n.id.as_str().to_string(), True)
            case _: pass
        match a.value:
            case Some(v):
                self.generate_expr(deref(v))
            case None:
                self.emit("Default::default()")
        self.emit(";\n")

    def emit_for(self, f: ast.StmtFor):
        iter_expr_f = ast.Expr.clone(as_ref(deref(f.iter)))
        is_map = self.is_dict_like_expr(iter_expr_f.clone())
        is_list = self.is_list_like_expr(iter_expr_f.clone())
        is_attr = False
        match as_ref(deref(f.iter)):
            case ast.Expr.Attribute(_): is_attr = True
            case ast.Expr.Subscript(_): is_attr = True
            case _: pass
        self.emit("for __q in (")
        self.generate_expr_no_clone(deref(f.iter))
        if is_map:
            self.emit(").keys() {\n")
        elif is_list or is_attr:
            self.emit(").iter() {\n")
        else:
            self.emit(").into_iter() {\n")
        self.emit("let ")
        match as_ref(deref(f.target)):
            case ast.Expr.Name(n):
                self.emit(n.id.as_str().to_string())
            case _:
                self.emit("_")
        self.emit(" = quiche_runtime::check!(__q);\n")
        self.enter_var_scope()
        for s in f.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}\n")

    def emit_if(self, i: ast.StmtIf):
        self.emit("if ")
        self.generate_expr(deref(i.test))
        self.emit(" {\n")
        self.enter_var_scope()
        for s in i.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}")
        for clause in i.elif_else_clauses:
            match clause.test:
                case Some(t):
                    self.emit(" else if ")
                    self.generate_expr(t)
                    self.emit(" {\n")
                    self.enter_var_scope()
                    for s in clause.body:
                        self.generate_stmt(s)
                    self.exit_var_scope()
                    self.emit("}")
                case None:
                    self.emit(" else {\n")
                    self.enter_var_scope()
                    for s in clause.body:
                        self.generate_stmt(s)
                    self.exit_var_scope()
                    self.emit("}")
        self.emit("\n")

    def emit_while(self, w: ast.StmtWhile):
        self.emit("while ")
        self.generate_expr(deref(w.test))
        self.emit(" {\n")
        self.enter_var_scope()
        for s in w.body:
            self.generate_stmt(s)
        self.exit_var_scope()
        self.emit("}\n")

    def emit_class_def(self, c: ast.StmtClassDef):
        is_enum = False
        is_extern = False
        extern_path = ""
        no_generic = False
        for dec in c.decorator_list.clone():
            match as_ref(dec.expression):
                case ast.Expr.Name(n):
                    if n.id.as_str().to_string() == "enum":
                        is_enum = True
                    if n.id.as_str().to_string() == "extern":
                        is_extern = True
                case ast.Expr.Call(call):
                    match as_ref(deref(call.func)):
                        case ast.Expr.Name(func_node):
                            if func_node.id.as_str().to_string() == "extern":
                                is_extern = True
                                for kw in call.arguments.keywords.clone():
                                    match as_ref(kw.arg):
                                        case Some(ident):
                                            arg_name = ident.as_str().to_string()
                                            if arg_name == "path":
                                                match as_ref(kw.value):
                                                    case ast.Expr.StringLiteral(s):
                                                        extern_path = s.value.to_string()
                                                    case _: pass
                                            elif arg_name == "no_generic":
                                                match as_ref(kw.value):
                                                    case ast.Expr.BooleanLiteral(b):
                                                        no_generic = b.value
                                                    case ast.Expr.Name(n):
                                                        if n.id.as_str().to_string() == "true":
                                                            no_generic = True
                                                    case _: pass
                                        case _: pass
                        case _: pass
                case _: pass

        class_name = c.name.as_str().to_string()
        self.symbols.insert(class_name.clone(), types.Symbol.clazz(class_name.clone(), is_extern))

        if is_extern:
            if extern_path != "":
                self.emit("pub type ")
                self.emit(c.name.as_str().to_string())
                if no_generic:
                    self.emit(" = ")
                    self.emit(extern_path)
                    self.emit(";\n")
                else:
                    self.emit("<T> = ")
                    self.emit(extern_path)
                    self.emit("<T>;\n")
            else:
                self.emit("// Extern class ")
                self.emit(c.name.as_str().to_string())
                self.emit("\n")
            return

        if is_enum:
            self.emit("#[derive(Clone, Debug)]\n")
            self.emit("pub enum ")
        else:
            self.emit("#[derive(Clone, Debug, Default)]\n")
            self.emit("pub struct ")
        self.emit(c.name.as_str().to_string())
        self.emit(" {\n")

        if is_enum:
            for s in c.body.clone():
                match s:
                    case ast.Stmt.AnnAssign(a):
                        match as_ref(deref(a.target)):
                            case ast.Expr.Name(n):
                                self.emit(n.id.as_str().to_string())
                                self.emit("(")
                                match deref(a.annotation):
                                    case ast.Expr.List(l):
                                        idx_enum: usize = 0
                                        for t in l.elts.clone():
                                            if idx_enum > 0: self.emit(", ")
                                            t_str_enum = self.type_to_string(t)
                                            self.emit(t_str_enum)
                                            idx_enum = idx_enum + 1
                                    case _: pass
                                self.emit("),\n")
                            case _: pass
                    case _: pass
        else:
            for s in c.body.clone():
                match s:
                    case ast.Stmt.AnnAssign(a):
                        match as_ref(deref(a.target)):
                            case ast.Expr.Name(n):
                                self.emit("pub ")
                                self.emit(n.id.as_str().to_string())
                                self.emit(": ")
                                ann_str_f = self.type_to_string(ast.Expr.clone(as_ref(deref(a.annotation))))
                                self.register_class_field(class_name.clone(), n.id.as_str().to_string(), ann_str_f.clone())
                                self.emit(ann_str_f)
                                self.emit(",\n")
                            case _: pass
                    case _: pass
        self.emit("}\n")

        if not is_enum:
            self.emit("impl ")
            self.emit(c.name.as_str().to_string())
            self.emit(" {\n")
            self.set_current_class(class_name.clone())
            for s in c.body:
                match s:
                    case ast.Stmt.FunctionDef(_):
                        self.generate_stmt(s)
                    case _: pass
            self.clear_current_class()
            self.emit("}\n")

    def emit_match(self, m: ast.StmtMatch):
        self.emit("match ")
        self.generate_expr(deref(m.subject))
        self.emit(" {\n")
        for case_ in m.cases:
            self.generate_pattern(ast.Pattern.clone(as_ref(case_.pattern)))
            match case_.guard:
                case Some(g):
                    self.emit(" if ")
                    self.generate_expr(deref(g))
                case None: pass
            self.emit(" => {\n")
            self.enter_var_scope()
            for s in case_.body:
                self.generate_stmt(s)
            self.exit_var_scope()
            self.emit("}\n")
        self.emit("}\n")

    def emit_import(self, i: ast.StmtImport):
        dot_imp = "."
        sep_imp = "::"
        for alias in i.names:
            is_root_module = self.current_module_path == "" or self.current_module_path == "main" or self.current_module_path == "lib"
            alias_name_raw = alias.name.as_str().to_string()
            rust_p = "rust."
            std_p = "std."
            alias_name = alias.name.as_str().to_string()
            match alias.asname.clone():
                case Some(a): alias_name = a.as_str().to_string()
                case None: pass

            match self.import_paths.get(alias_name.clone()):
                case Some(rust_path):
                    if is_root_module and rust_path.starts_with(as_ref("crate::")):
                        self.register_import_symbol(alias_name.clone())
                        continue
                    self.emit("use ")
                    self.emit(rust_path)
                    match alias.asname.clone():
                        case Some(_):
                            self.emit(" as ")
                            self.emit(alias_name.clone())
                        case None: pass
                    self.emit(";\n")
                case None:
                    if not alias_name_raw.starts_with(rust_p.as_str()) and not alias_name_raw.starts_with(std_p.as_str()):
                        if is_root_module and alias.asname.is_none() and not alias_name_raw.contains(as_ref(".")):
                            self.register_import_symbol(alias_name.clone())
                            continue
                        self.emit("use crate::")
                    else:
                        self.emit("use ")
                    dot_v = "."
                    sep_v = "::"
                    self.emit(alias_name_raw.replace(dot_v.as_str(), sep_v.as_str()))
                    self.emit(";\n")
            
            self.register_import_symbol(alias_name.clone())

    def emit_import_from(self, i: ast.StmtImportFrom):
        mod_sep = "."
        mod_col = "::"
        for alias in i.names:
            match i.module.clone():
                case Some(m):
                    if m.as_str().to_string() == "lib.test": return
                case None: pass
            alias_name = alias.name.as_str().to_string()
            match alias.asname.clone():
                case Some(a): alias_name = a.as_str().to_string()
                case None: pass

            match self.import_paths.get(alias_name.clone()):
                case Some(rust_path):
                    self.emit("use ")
                    self.emit(rust_path)
                    match alias.asname.as_ref():
                        case Some(_):
                            self.emit(" as ")
                            self.emit(alias_name.clone())
                        case None: pass
                    self.emit(";\n")
                case None:
                    self.emit("use ")
                    match i.module.clone():
                        case Some(m):
                            m_str = m.as_str().to_string()
                            if m_str == "lib.test": return
                            r_p = "rust."
                            s_p = "std."
                            if not m_str.starts_with(r_p.as_str()) and not m_str.starts_with(s_p.as_str()):
                                if i.level == 0: self.emit("crate::")
                        case None: pass
                    l_lvl = i.level
                    k_lvl: u32 = 0
                    while k_lvl < l_lvl:
                        self.emit("super::")
                        k_lvl = k_lvl + 1
                    match i.module.clone():
                        case Some(m):
                            mod_name = m.as_str().to_string()
                            if mod_name == "rust":
                                mod_name = ""
                            elif mod_name.starts_with(as_ref("rust.")):
                                mod_name = mod_name.replace(as_ref("rust."), as_ref(""))
                            if mod_name != "":
                                self.emit(mod_name.replace(mod_sep.as_str(), mod_col.as_str()))
                                self.emit("::")
                        case None: pass
                    self.emit(alias.name.as_str().to_string().replace(mod_sep.as_str(), mod_col.as_str()))
                    match alias.asname.as_ref():
                        case Some(a):
                            self.emit(" as ")
                            self.emit(a.as_str().to_string())
                        case None: pass
                    self.emit(";\n")
            self.register_import_symbol(alias_name.clone())

    def generate_expr(self, expr: ast.Expr):
        match expr:
            case ast.Expr.NumberLiteral(n): self.emit_number_literal(n)
            case ast.Expr.StringLiteral(s): self.emit_string_literal(s)
            case ast.Expr.BooleanLiteral(b): self.emit_boolean_literal(b)
            case ast.Expr.NoneLiteral(_): self.emit("None")
            case ast.Expr.Name(n):
                name_str = n.id.as_str().to_string()
                if self.is_type_or_mod(name_str.clone()):
                    self.emit(name_str)
                else:
                    match self.usage_ledger.get(name_str.clone()):
                        case Some(info):
                            is_terminal = (info.last_use_idx == self.current_stmt_idx)
                            if is_terminal:
                                self.emit(name_str)
                            else:
                                if self.clone_names:
                                    self.emit(name_str)
                                    self.emit(".clone()")
                                elif info.is_mutated:
                                    self.emit("&mut ")
                                    self.emit(name_str)
                                else:
                                    self.emit("&")
                                    self.emit(name_str)
                        case None:
                            if self.clone_names:
                                self.emit(name_str)
                                self.emit(".clone()")
                            else:
                                self.emit(name_str)
            case ast.Expr.Call(c): self.emit_call(c)
            case ast.Expr.List(l): self.emit_list(l)
            case ast.Expr.BinOp(b): self.emit_bin_op(b)
            case ast.Expr.BoolOp(b): self.emit_bool_op(b)
            case ast.Expr.UnaryOp(u): self.emit_unary_op(u)
            case ast.Expr.If(i): self.emit_expr_if(i)
            case ast.Expr.Compare(c): self.emit_compare(c)
            case ast.Expr.Tuple(t): self.emit_expr_tuple(t)
            case ast.Expr.Attribute(a): self.emit_attribute(a)
            case ast.Expr.Subscript(s): self.emit_subscript(s)
            case ast.Expr.Lambda(l): self.emit_lambda(l)
            case ast.Expr.FString(f): self.emit_fstring(f)
            case ast.Expr.Dict(d): self.emit_dict(d)
            case _: self.emit("/* expr */")

    def emit_number_literal(self, n: ast.ExprNumberLiteral):
        match n.value:
            case ast.Number.Int(i):
                self.emit(i.to_string())
            case ast.Number.Float(f):
                s_f = f.to_string()
                if not s_f.contains(as_ref(".")):
                    s_f = s_f + as_ref(".0")
                self.emit(s_f)
            case _: self.emit("0")

    def emit_string_literal(self, s: ast.ExprStringLiteral):
        self.emit("String::from(\"")
        esc = escape_rust_string(s.value.to_string())
        self.emit(esc)
        self.emit("\")")

    def emit_boolean_literal(self, b: ast.ExprBooleanLiteral):
        if b.value: self.emit("true")
        else: self.emit("false")

    def emit_call(self, c: ast.ExprCall):
        func_name = ""
        match as_ref(deref(c.func)):
            case ast.Expr.Lambda(_):
                self.generate_expr(deref(c.func))
                self.emit("(")
                idx_lc = 0
                for arg in c.arguments.args:
                    if idx_lc > 0: self.emit(", ")
                    self.generate_expr(arg)
                    idx_lc = idx_lc + 1
                self.emit(")")
                return
            case _: pass
        match as_ref(deref(c.func)):
            case ast.Expr.Name(n):
                func_name = n.id.as_str().to_string()
            case _: pass

        if func_name == "as_ref":
            if c.arguments.args.len() > 0:
                self.emit("&")
                self.generate_expr_no_clone(ast.Expr.clone(as_ref(c.arguments.args[0])))
            return
        if func_name == "as_mut":
            if c.arguments.args.len() > 0:
                self.emit("&mut ")
                self.generate_expr_no_clone(ast.Expr.clone(as_ref(c.arguments.args[0])))
            return
        if func_name == "deref":
            if c.arguments.args.len() > 0:
                self.emit("*")
                self.generate_expr_no_clone(ast.Expr.clone(as_ref(c.arguments.args[0])))
            return
        if func_name == "exit":
            self.emit("std::process::exit(")
            idx_exit: usize = 0
            for arg in c.arguments.args:
                if idx_exit > 0: self.emit(", ")
                self.generate_expr(arg)
                idx_exit = idx_exit + 1
            self.emit(")")
            return

        if func_name == "print":
            self.emit("println!(\"{:?}\", ")
            first_p = True
            for arg in c.arguments.args:
                if not first_p: self.emit(", ")
                first_p = False
                self.generate_expr(arg)
            self.emit(")")
        elif func_name == "print_str":
            self.emit("println!(\"{}\", ")
            first_ps = True
            for arg in c.arguments.args:
                if not first_ps: self.emit(", ")
                first_ps = False
                self.generate_expr(arg)
            self.emit(")")
        elif func_name == "len":
            if c.arguments.args.len() == 1:
                target_len = ast.Expr.clone(as_ref(c.arguments.args[0]))
                self.generate_expr(target_len)
                is_list_len = self.is_list_like_expr(target_len.clone())
                is_dict_len = self.is_dict_like_expr(target_len.clone())
                is_attr = False
                match as_ref(deref(c.arguments.args[0])):
                    case ast.Expr.Attribute(_): is_attr = True
                    case ast.Expr.Subscript(_): is_attr = True
                    case _: pass
                if is_list_len or is_dict_len or is_attr:
                    self.emit(".borrow().len()")
                else:
                    self.emit(".len()")
            else: self.emit("0")
        elif func_name == "assert_eq" or func_name == "assert_str_eq":
            self.emit("assert_eq!(")
            if c.arguments.args.len() >= 2:
                self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[0])))
                self.emit(", ")
                self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[1])))
                if c.arguments.args.len() > 2:
                    self.emit(", \"{:?}\", ")
                    self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[2])))
            self.emit(")")
        elif func_name == "assert_true":
            self.emit("assert!(")
            if c.arguments.args.len() >= 1:
                self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[0])))
                if c.arguments.args.len() > 1:
                    self.emit(", \"{:?}\", ")
                    self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[1])))
            self.emit(")")
        elif func_name == "range":
            if c.arguments.args.len() == 1:
                self.emit("0..")
                self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[0])))
            elif c.arguments.args.len() >= 2:
                self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[0])))
                self.emit("..")
                self.generate_expr(ast.Expr.clone(as_ref(c.arguments.args[1])))
        elif c.arguments.keywords.len() > 0:
            self.generate_expr(deref(c.func))
            self.emit(" { ")
            i_kw: usize = 0
            for kw in c.arguments.keywords:
                if i_kw > 0: self.emit(", ")
                match kw.arg:
                    case Some(arg_id):
                        self.emit(arg_id.as_str().to_string())
                        self.emit(": ")
                        self.generate_expr(ast.Expr.clone(as_ref(kw.value)))
                    case None: pass
                i_kw = i_kw + 1
            self.emit(" }")
        else:
            match as_ref(deref(c.func)):
                case ast.Expr.Attribute(at):
                    is_static_call = False
                    match self.get_root_name(ast.Expr.clone(as_ref(deref(at.value)))):
                        case Some(root_name):
                            if self.is_type_or_mod(root_name.clone()):
                                is_static_call = True
                            else:
                                match self.symbols.lookup(root_name):
                                    case Some(s):
                                        if s.is_class or s.is_extern:
                                            is_static_call = True
                                    case None: pass
                        case None: pass
                    if at.attr.as_str().to_string() == "new": is_static_call = True

                    if is_static_call:
                        attr_name_inner = at.attr.as_str().to_string()
                        if attr_name_inner == "new":
                            match as_ref(deref(at.value)):
                                case ast.Expr.Name(n):
                                    base_name = n.id.as_str().to_string()
                                    if base_name == "List" or base_name == "Vec":
                                        self.emit("std::rc::Rc::new(Vec::new())")
                                        return
                                    if base_name == "Dict" or base_name == "HashMap":
                                        self.emit("std::rc::Rc::new(std::collections::HashMap::new())")
                                        return
                                case ast.Expr.Subscript(s):
                                    base_name_s = self.type_to_string(deref(s.value))
                                    if base_name_s == "Vec":
                                        inner_s = self.type_to_string(deref(s.slice))
                                        self.emit("std::rc::Rc::new(Vec::<")
                                        self.emit(inner_s)
                                        self.emit(">::new())")
                                        return
                                    if base_name_s == "std::collections::HashMap":
                                        match deref(s.slice):
                                            case ast.Expr.Tuple(t):
                                                if t.elts.len() == 2:
                                                    k_s = self.type_to_string(t.elts[0])
                                                    v_s = self.type_to_string(t.elts[1])
                                                    self.emit("std::rc::Rc::new(std::collections::HashMap::<")
                                                    self.emit(k_s)
                                                    self.emit(", ")
                                                    self.emit(v_s)
                                                    self.emit(">::new())")
                                                    return
                                            case _:
                                                pass
                                        self.emit("std::rc::Rc::new(std::collections::HashMap::new())")
                                        return
                                case _: pass

                        if attr_name_inner == "clone":
                            self.generate_expr(deref(c.func))
                            self.emit("(")
                            idx_arg_s = 0
                            for arg_c in c.arguments.args.clone():
                                if idx_arg_s > 0: self.emit(", ")
                                self.generate_expr(arg_c)
                                idx_arg_s = idx_arg_s + 1
                            self.emit(")")
                        else:
                            self.emit("quiche_runtime::check!(quiche_runtime::call!(")
                            self.generate_expr_no_clone(deref(c.func))
                            for arg_c in c.arguments.args.clone():
                                self.emit(", ")
                                self.generate_expr(arg_c)
                            self.emit("))")
                    else:
                        # Method call on an instance
                        # Method call on an instance
                        self.emit("quiche_runtime::check!(")
                        
                        attr_name_inner = at.attr.as_str().to_string()
                        receiver_expr = ast.Expr.clone(as_ref(deref(at.value)))
                        is_list_receiver = self.is_list_like_expr(receiver_expr.clone())
                        is_dict_receiver = self.is_dict_like_expr(receiver_expr.clone())
                        
                        if attr_name_inner == "len" and (is_list_receiver or is_dict_receiver):
                            self.generate_expr_no_clone(ast.Expr.clone(as_ref(deref(at.value))))
                            self.emit(".len()")
                            self.emit(")")
                            return

                        key_needs_ref = False
                        if attr_name_inner == "get": key_needs_ref = True
                        if attr_name_inner == "remove": key_needs_ref = True
                        if attr_name_inner == "contains_key": key_needs_ref = True
                        if attr_name_inner == "pop": key_needs_ref = True

                        is_list_method = False
                        if attr_name_inner == "append": is_list_method = True
                        elif attr_name_inner == "pop": is_list_method = True
                        elif attr_name_inner == "push": is_list_method = True
                        elif attr_name_inner == "clear": is_list_method = True
                        elif attr_name_inner == "reverse": is_list_method = True
                        elif attr_name_inner == "sort": is_list_method = True
                        elif attr_name_inner == "insert": is_list_method = True
                        elif attr_name_inner == "extend": is_list_method = True

                        is_dict_mut = False
                        if attr_name_inner == "insert": is_dict_mut = True
                        elif attr_name_inner == "remove": is_dict_mut = True
                        elif attr_name_inner == "clear": is_dict_mut = True
                        elif attr_name_inner == "update": is_dict_mut = True
                        elif attr_name_inner == "pop": is_dict_mut = True

                        is_mut_call = (is_list_receiver and is_list_method) or (is_dict_receiver and is_dict_mut)

                        if is_mut_call:
                            self.emit("std::rc::Rc::make_mut(&mut ")
                            self.generate_expr_no_clone(ast.Expr.clone(as_ref(deref(at.value))))
                            self.emit(")")
                        else:
                             self.generate_expr_no_clone(ast.Expr.clone(as_ref(deref(at.value))))

                        self.emit(".")

                        if is_list_method and is_list_receiver:
                            if attr_name_inner == "append": self.emit("push(")
                            elif attr_name_inner == "pop": self.emit("pop(")
                            elif attr_name_inner == "push": self.emit("push(")
                            else:
                                self.emit(attr_name_inner.clone())
                                self.emit("(")
                        elif is_dict_receiver and attr_name_inner == "items":
                            self.emit("iter(")
                        else:
                            self.emit(attr_name_inner.clone())
                            self.emit("(")

                        idx_arg_m = 0
                        for arg in c.arguments.args.clone():
                            if idx_arg_m > 0: self.emit(", ")
                            if key_needs_ref and idx_arg_m == 0: self.emit("&")
                            self.generate_expr(arg)
                            idx_arg_m = idx_arg_m + 1
                        self.emit(")")
                        if is_dict_receiver and attr_name_inner == "get": self.emit(".cloned()")
                        self.emit(")")
                case _:
                    self.emit("quiche_runtime::check!(quiche_runtime::call!(")
                    self.generate_expr_no_clone(deref(c.func))
                    for arg_c in c.arguments.args.clone():
                        self.emit(", ")
                        self.generate_expr(arg_c)
                    self.emit("))")

    def emit_list(self, l: ast.ExprList):
        self.emit("std::rc::Rc::new(vec![")
        idx_l: usize = 0
        for e in l.elts:
            if idx_l > 0: self.emit(", ")
            self.generate_expr(e)
            idx_l = idx_l + 1
        self.emit("]))")

    def emit_bin_op(self, b: ast.ExprBinOp):
        self.generate_expr(deref(b.left))
        match b.op:
            case ast.Operator.Add: self.emit(" + ")
            case ast.Operator.Sub: self.emit(" - ")
            case ast.Operator.Mult: self.emit(" * ")
            case ast.Operator.Div: self.emit(" / ")
            case _: self.emit(" + ")
        self.generate_expr(deref(b.right))

    def emit_bool_op(self, b: ast.ExprBoolOp):
        op_str_b = " && "
        match b.op:
            case ast.BoolOp.Or: op_str_b = " || "
            case _: pass
        idx_b: usize = 0
        for v in b.values.clone():
            if idx_b > 0: self.emit(op_str_b.clone())
            self.emit("(")
            self.generate_expr(v)
            self.emit(")")
            idx_b = idx_b + 1

    def emit_unary_op(self, u: ast.ExprUnaryOp):
        match u.op:
            case ast.UnaryOp.Not: self.emit("!")
            case ast.UnaryOp.Invert: self.emit("!")
            case ast.UnaryOp.UAdd: self.emit("+")
            case ast.UnaryOp.USub: self.emit("-")
        self.generate_expr(deref(u.operand))

    def emit_expr_if(self, i: ast.ExprIf):
        self.emit("if ")
        self.generate_expr(deref(i.test))
        self.emit(" { ")
        self.generate_expr(deref(i.body))
        self.emit(" } else { ")
        self.generate_expr(deref(i.orelse))
        self.emit(" }")

    def emit_compare(self, c: ast.ExprCompare):
        self.generate_expr(deref(c.left))
        idx_c: usize = 0
        while idx_c < c.ops.len():
            op = c.ops[idx_c]
            self.emit(" ")
            match op:
                case ast.CmpOp.Eq: self.emit("==")
                case ast.CmpOp.NotEq: self.emit("!=")
                case ast.CmpOp.Lt: self.emit("<")
                case ast.CmpOp.LtE: self.emit("<=")
                case ast.CmpOp.Gt: self.emit(">")
                case ast.CmpOp.GtE: self.emit(">=")
                case _: self.emit("?")
            self.emit(" ")
            self.generate_expr(ast.Expr.clone(as_ref(c.comparators[idx_c])))
            idx_c = idx_c + 1

    def emit_expr_tuple(self, t: ast.ExprTuple):
        self.emit("(")
        idx_t: usize = 0
        for e in t.elts:
            if idx_t > 0: self.emit(", ")
            self.generate_expr(e)
            idx_t = idx_t + 1
        self.emit(")")

    def emit_attribute(self, a: ast.ExprAttribute):
        target_attr = deref(a.value)
        is_static_attr = False
        match self.get_root_name(ast.Expr.clone(as_ref(target_attr))):
            case Some(root_name):
                if self.is_type_or_mod(root_name.clone()):
                    is_static_attr = True
                else:
                    match self.symbols.lookup(root_name):
                        case Some(s):
                            if s.is_class or s.is_extern:
                                is_static_attr = True
                        case None: pass
            case None: pass
        if a.attr.as_str().to_string() == "new": is_static_attr = True
        
        match as_ref(target_attr):
            case ast.Expr.Subscript(s):
                if is_static_attr:
                    full_expr = ast.Expr.clone(as_ref(target_attr))
                    base_type = self.type_to_string(full_expr)
                    if base_type.contains(as_ref("<")):
                        base_type = base_type.replace(as_ref("<"), as_ref("::<"))
                    self.emit(base_type)
                else:
                    self.generate_expr_no_clone(ast.Expr.clone(as_ref(target_attr)))
            case _:
                self.generate_expr_no_clone(ast.Expr.clone(as_ref(target_attr)))
        if is_static_attr: self.emit("::")
        else: self.emit(".")
        self.emit(a.attr.as_str().to_string())

    def emit_attribute_target(self, a: ast.ExprAttribute):
        target_attr = deref(a.value)
        is_static_attr = False
        match self.get_root_name(ast.Expr.clone(as_ref(target_attr))):
            case Some(root_name):
                if self.is_type_or_mod(root_name.clone()):
                    is_static_attr = True
                else:
                    match self.symbols.lookup(root_name):
                        case Some(s):
                            if s.is_class or s.is_extern:
                                is_static_attr = True
                        case None: pass
            case None: pass
        if a.attr.as_str().to_string() == "new": is_static_attr = True

        match as_ref(target_attr):
            case ast.Expr.Attribute(inner):
                self.emit_attribute_target(inner)
            case ast.Expr.Name(n):
                self.emit(n.id.as_str().to_string())
            case _:
                self.generate_expr_no_clone(ast.Expr.clone(as_ref(target_attr)))
        if is_static_attr: self.emit("::")
        else: self.emit(".")
        self.emit(a.attr.as_str().to_string())

    def emit_subscript(self, s: ast.ExprSubscript):
        target_type_s = self.infer_expr_type(ast.Expr.clone(as_ref(s.value)))
        is_tuple_target = self.is_tuple_expr(ast.Expr.clone(as_ref(s.value)))
        tuple_via_symbol = False
        match as_ref(deref(s.value)):
            case ast.Expr.Name(n):
                match self.symbols.lookup(n.id.as_str().to_string()):
                    case Some(sym):
                        if sym.type_name.contains(as_ref("(")) and sym.type_name.contains(as_ref(")")):
                            tuple_via_symbol = True
                    case None: pass
            case _: pass
        tuple_via_registry = False
        match as_ref(deref(s.value)):
            case ast.Expr.Name(n):
                match self.tuple_vars.get(n.id.as_str().to_string()):
                    case Some(_):
                        tuple_via_registry = True
                    case None: pass
            case ast.Expr.Subscript(inner):
                match as_ref(deref(inner.value)):
                    case ast.Expr.Name(n):
                        match self.tuple_vars.get(n.id.as_str().to_string()):
                            case Some(_):
                                tuple_via_registry = True
                            case None: pass
                    case _: pass
            case _: pass

        if tuple_via_registry or tuple_via_symbol or is_tuple_target or target_type_s == "Tuple" or target_type_s.starts_with(as_ref("Tuple")) or target_type_s.starts_with(as_ref("(")):
            self.generate_expr(deref(s.value))
            self.emit(".")
            match deref(s.slice):
                case ast.Expr.NumberLiteral(n):
                    match n.value:
                        case ast.Number.Int(i):
                            self.emit(i.to_string())
                        case _: self.emit("0")
                case _: self.emit("0")
        else:
            is_map = self.is_dict_like_expr(ast.Expr.clone(as_ref(deref(s.value))))
            is_list = self.is_list_like_expr(ast.Expr.clone(as_ref(deref(s.value))))
            is_neg_s = False
            sl_s = deref(s.slice)
            match as_ref(sl_s):
                case ast.Expr.UnaryOp(u):
                    match u.op:
                        case ast.UnaryOp.USub: is_neg_s = True
                        case _: pass
                case _: pass

            if is_neg_s:
                match sl_s:
                    case ast.Expr.UnaryOp(u):
                        self.generate_expr(ast.Expr.clone(as_ref(deref(s.value))))
                        if is_list:
                            self.emit("[")
                            self.generate_expr(ast.Expr.clone(as_ref(deref(s.value))))
                            self.emit(".len() - ")
                            self.generate_expr(deref(u.operand))
                            self.emit("].clone()")
                        else:
                            self.emit("[")
                            self.generate_expr(ast.Expr.clone(as_ref(deref(s.value))))
                            self.emit(".len() - ")
                            self.generate_expr(deref(u.operand))
                            self.emit("]")
                    case _: pass
            else:
                self.generate_expr(deref(s.value))
                if is_map:
                    self.emit("[&")
                    self.generate_expr(sl_s)
                    self.emit("].clone()")
                elif is_list:
                    self.emit("[")
                    self.generate_expr(sl_s)
                    self.emit("].clone()")
                else:
                    self.emit("[")
                    self.generate_expr(sl_s)
                    self.emit("]")

    def emit_lambda(self, l: ast.ExprLambda):
        self.emit("(|")
        match l.parameters:
            case Some(p):
                idx_lam = 0
                for arg_def in p.args.clone():
                    if idx_lam > 0: self.emit(", ")
                    self.emit(arg_def.parameter.name.as_str().to_string())
                    idx_lam = idx_lam + 1
            case None: pass
        self.emit("| ")
        self.generate_expr_no_clone(deref(l.body))
        self.emit(")")

    def emit_fstring(self, f: ast.ExprFString):
        self.emit("format!(\"")
        f_args: List[ast.Expr] = []
        for part in f.value:
            match part:
                case ast.FStringPart.Literal(lit):
                    self.emit(lit.value.to_string())
                case ast.FStringPart.FString(fs):
                    for element in fs.elements:
                        match element:
                            case ast.InterpolatedStringElement.Literal(l):
                                self.emit(l.value.to_string())
                            case ast.InterpolatedStringElement.Interpolation(i):
                                self.emit("{}")
                                f_args.push(ast.Expr.clone(as_ref(deref(i.expression))))
        self.emit("\"")
        for arg in f_args:
            self.emit(", ")
            self.generate_expr(arg)
        self.emit(")")

    def emit_dict(self, d: ast.ExprDict):
        self.emit("std::rc::Rc::new(std::collections::HashMap::from([")
        idx_dict = 0
        for item in d.items:
            if idx_dict > 0: self.emit(", ")
            key_val = as_ref(item).key
            val_val = as_ref(deref(as_ref(item).value))
            match key_val:
                case Some(k):
                    self.emit("(")
                    self.generate_expr(ast.Expr.clone(as_ref(k)))
                    self.emit(", ")
                    self.generate_expr(ast.Expr.clone(as_ref(val_val)))
                    self.emit(")")
                case None:
                    self.emit("/* **kwargs */")
            idx_dict = idx_dict + 1
        self.emit("]))")

    def infer_expr_type(self, expr: ast.Expr) -> String:
        match expr:
            case ast.Expr.NumberLiteral(_): return "i32"
            case ast.Expr.StringLiteral(_): return "String"
            case ast.Expr.BooleanLiteral(_): return "bool"
            case ast.Expr.Tuple(_): return "Tuple"
            case ast.Expr.List(_): return "Vec"
            case ast.Expr.Dict(_): return "std::collections::HashMap"
            case ast.Expr.Call(c):
                match as_ref(deref(c.func)):
                    case ast.Expr.Name(n):
                        return n.id.as_str().to_string()
                    case ast.Expr.Attribute(a):
                        if a.attr.as_str().to_string() == "new":
                            match as_ref(deref(a.value)):
                                case ast.Expr.Name(nv):
                                    return nv.id.as_str().to_string()
                                case ast.Expr.Subscript(sv):
                                    return self.type_to_string(deref(sv.value.clone()))
                                case _: pass
                    case _: pass
                return "unknown"
            case ast.Expr.Name(n):
                match self.symbols.lookup(n.id.as_str().to_string()):
                    case Some(s):
                        if s.type_name.starts_with(as_ref("(")): return "Tuple"
                        if s.type_name.starts_with(as_ref("Tuple")): return "Tuple"
                        return s.type_name
                    case None: return "unknown"
            case _: return "unknown"

    def type_to_string(self, expr: ast.Expr) -> String:
        match expr:
            case ast.Expr.Name(n):
                s = n.id.as_str().to_string()
                if s == "List": return "Vec"
                if s == "Dict": return "std::collections::HashMap"
                if s == "StrRef": return "&str"
                return s
            case ast.Expr.Subscript(s):
                base = self.type_to_string(deref(s.value))
                if base == "std::collections::HashMap":
                    match deref(s.slice):
                        case ast.Expr.Tuple(t):
                            res = RustString.new()
                            res = q_push(res, "std::rc::Rc<std::collections::HashMap<")
                            idx_h: usize = 0
                            for e in t.elts:
                                if idx_h > 0: res = q_push(res, ", ")
                                res = q_push(res, self.type_to_string(e))
                                idx_h = idx_h + 1
                            res = q_push(res, ">>")
                            return res
                        case _:
                            pass
                if base == "Tuple":
                    match deref(s.slice):
                        case ast.Expr.Tuple(t):
                            res = RustString.new()
                            res = q_push(res, "(")
                            idx_t: usize = 0
                            for e in t.elts:
                                if idx_t > 0: res = q_push(res, ", ")
                                res = q_push(res, self.type_to_string(e))
                                idx_t = idx_t + 1
                            res = q_push(res, ")")
                            return res
                        case _:
                            res = RustString.new()
                            res = q_push(res, "(")
                            res = q_push(res, self.type_to_string(deref(s.slice)))
                            res = q_push(res, ")")
                            return res
                inner = self.type_to_string(deref(s.slice))
                res = RustString.new()
                if base == "Vec":
                    res = q_push(res, "std::rc::Rc<Vec<")
                    res = q_push(res, inner)
                    res = q_push(res, ">>")
                    return res
                res = q_push(res, base)
                res = q_push(res, "<")
                res = q_push(res, inner)
                res = q_push(res, ">")
                return res
            case ast.Expr.Attribute(a):
                base_attr = self.type_to_string(deref(a.value))
                res_attr = RustString.new()
                res_attr = q_push(res_attr, base_attr)
                res_attr = q_push(res_attr, "::")
                res_attr = q_push(res_attr, a.attr.as_str().to_string())
                return res_attr
            case _: return "Any"

    def is_tuple_expr(self, expr: ast.Expr) -> bool:
        match expr:
            case ast.Expr.Tuple(_): return True
            case ast.Expr.Name(n):
                match self.symbols.lookup(n.id.as_str().to_string()):
                    case Some(s):
                        if s.type_name.starts_with(as_ref("(")): return True
                        if s.type_name.starts_with(as_ref("Tuple")): return True
                    case None: pass
                return False
            case ast.Expr.Subscript(s): return self.is_tuple_expr(deref(s.value))
            case _: return False

    def get_root_name(self, expr: ast.Expr) -> Option[String]:
        match expr:
            case ast.Expr.Name(n): return Some(n.id.as_str().to_string())
            case ast.Expr.Attribute(a): return self.get_root_name(deref(a.value))
            case _: return None

    def is_type_or_mod(self, name: String) -> bool:
        if name == "self": return False
        match self.symbols.lookup(name.clone()):
            case Some(s):
                if s.is_module: return True
                if s.is_class: return True
                if s.is_extern: return True
            case None: pass
        if name == "ast": return True
        if name == "compiler": return True
        if name == "types": return True
        if name == "rustpython_parser": return True
        if name == "ruff_python_parser": return True
        if name == "ruff_python_ast": return True
        if name == "std": return True
        if name == "crate": return True
        first_char = name.chars().next()
        match first_char:
            case Some(c):
                if c.is_uppercase(): return True
            case None: pass
        return False

    def is_var_defined(self, name: String) -> bool:
        match self.symbols.lookup(name):
            case Some(_): return True
            case None: return False

    def is_var_defined_in_scopes(self, name: String) -> bool:
        i = self.defined_vars.len()
        while i > 0:
            i = i - 1
            scope = as_ref(self.defined_vars[i])
            match scope.get(name.clone()):
                case Some(_): return True
                case None: pass
        return False

    def enter_var_scope(self):
        self.defined_vars.push(Dict[String, bool].new())

    def exit_var_scope(self):
        sz = self.defined_vars.len()
        if sz > 1:
            self.defined_vars.pop()

    def mark_var_defined(self, name: String):
        sz = self.defined_vars.len()
        idx = sz - 1
        current_scope = as_mut(self.defined_vars[idx])
        current_scope.insert(name, True)
    
    def define_var(self, name: String):
        # Insert as inferred variable
        self.symbols.insert(name.clone(), types.Symbol.var(name.clone(), "inferred"))
        self.mark_var_defined(name)

    def expr_contains_name(self, expr: ast.Expr, name: String) -> bool:
        match expr:
            case ast.Expr.Name(n):
                return n.id.as_str().to_string() == name
            case ast.Expr.BinOp(b):
                if self.expr_contains_name(deref(b.left), name.clone()): return True
                return self.expr_contains_name(deref(b.right), name)
            case ast.Expr.BoolOp(b):
                for v in b.values.clone():
                    if self.expr_contains_name(v, name.clone()): return True
                return False
            case ast.Expr.UnaryOp(u):
                return self.expr_contains_name(deref(u.operand), name)
            case ast.Expr.Call(c):
                if self.expr_contains_name(deref(c.func), name.clone()): return True
                for arg in c.arguments.args.clone():
                    if self.expr_contains_name(arg, name.clone()): return True
                for kw in c.arguments.keywords.clone():
                    if self.expr_contains_name(ast.Expr.clone(as_ref(kw.value)), name.clone()): return True
                return False
            case ast.Expr.Attribute(a):
                return self.expr_contains_name(deref(a.value), name)
            case ast.Expr.Subscript(s):
                if self.expr_contains_name(deref(s.value), name.clone()): return True
                return self.expr_contains_name(deref(s.slice), name)
            case ast.Expr.Tuple(t):
                for e in t.elts:
                    if self.expr_contains_name(e, name.clone()): return True
                return False
            case ast.Expr.List(l):
                for e in l.elts:
                    if self.expr_contains_name(e, name.clone()): return True
                return False
            case ast.Expr.If(i):
                if self.expr_contains_name(deref(i.test), name.clone()): return True
                if self.expr_contains_name(deref(i.body), name.clone()): return True
                return self.expr_contains_name(deref(i.orelse), name)
            case ast.Expr.Compare(c):
                if self.expr_contains_name(deref(c.left), name.clone()): return True
                for comp in c.comparators.clone():
                    if self.expr_contains_name(comp, name.clone()): return True
                return False
            case _: return False

    def generate_pattern(self, pat: ast.Pattern):
        match pat:
            case ast.Pattern.MatchValue(v): self.generate_expr(deref(v.value))
            case ast.Pattern.MatchAs(a):
                match a.name:
                    case Some(n): self.emit(n.as_str().to_string())
                    case None: self.emit("_")
            case ast.Pattern.MatchClass(c):
                self.generate_expr(deref(c.cls))
                if c.arguments.patterns.len() > 0:
                    self.emit("(")
                    first_p = True
                    for p in c.arguments.patterns.clone():
                        if not first_p: self.emit(", ")
                        self.generate_pattern(p)
                        first_p = False
                    self.emit(")")
                elif c.arguments.keywords.len() > 0:
                    self.emit(" { ")
                    idx_kw_pat = 0
                    for kw in c.arguments.keywords.clone():
                        if idx_kw_pat > 0: self.emit(", ")
                        self.emit(kw.attr.as_str().to_string())
                        self.emit(": ")
                        self.generate_pattern(kw.pattern)
                        idx_kw_pat = idx_kw_pat + 1
                    self.emit(" }")
                else: self.emit(" { .. }")
            case _: self.emit("_")
