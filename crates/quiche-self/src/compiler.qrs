import ast

@extern(path="std::string::String", no_generic=True)
class RustString:
    def new() -> RustString: pass
    def push_str(self, s: StrRef): pass

class Codegen:
    output: RustString

    def __init__(self):
        self.output = RustString.new()

    def new() -> Codegen:
        return Codegen(output=RustString.new())

    def emit(self, s: String):
        self.output.push_str(as_ref(s))

    def generate_stmt(self, stmt: ast.Stmt):
        match stmt:
            case ast.Stmt.FunctionDef(f):
                self.emit("fn ")
                self.emit(f.name.to_string())
                self.emit("() {\n")
                for s in f.body:
                    self.generate_stmt(s)
                self.emit("}\n")
            case ast.Stmt.Expr(e):
                self.generate_expr(deref(e.value))
                self.emit(";\n")
            case ast.Stmt.Return(r):
                self.emit("return ")
                match r.value:
                    case Some(v):
                        self.generate_expr(deref(v))
                    case None:
                        pass
                self.emit(";\n")
            case ast.Stmt.Assign(a):
                # Simple single target assignment
                match as_ref(a.targets[0]):
                    case ast.Expr.Name(n):
                         self.emit("let ")
                         self.emit(n.id.to_string())
                         self.emit(" = ")
                    case _:
                         pass
                self.generate_expr(deref(a.value))
                self.emit(";\n")
            case _:
                self.emit("// Unimplemented stmt\n")

    def generate_expr(self, expr: ast.Expr):
        match expr:
            case ast.Expr.Constant(c):
                match c.value:
                    case ast.Constant.Int(i):
                        self.emit("42") # Placeholder until BigInt binding
                    case ast.Constant.Str(s):
                         self.emit("\"")
                         self.emit(s)
                         self.emit("\"")
                    case _:
                        self.emit("/* const */")
            case ast.Expr.Name(n):
                self.emit(n.id.to_string())
            case ast.Expr.BinOp(b):
                self.generate_expr(deref(b.left))
                # Operator mapping is needed, assume Add (+)
                self.emit(" + ")
                self.generate_expr(deref(b.right))
            case _:
                self.emit("/* expr */")
